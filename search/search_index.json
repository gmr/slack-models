{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"slack-models","text":"<p>Welcome to slack-models, a comprehensive Python library providing type-safe Pydantic models for working with the Slack API. This library offers structured data models for Slack events, webhooks, users, channels, files, and other API objects.</p>"},{"location":"#overview","title":"Overview","text":"<p>slack-models is designed to make working with Slack API data easier and more reliable by providing:</p> <ul> <li>Type Safety: Comprehensive Pydantic models with full type annotations</li> <li>Event Processing: Models for all major Slack event types including messages, reactions, and channel events</li> <li>Block Kit Support: Complete models for Slack's Block Kit framework including blocks, elements, and composition objects</li> <li>Webhook Support: Complete webhook payload models for event callbacks and verifications</li> <li>Data Validation: Automatic validation and parsing of Slack API responses</li> <li>Modern Python: Built for Python 3.12+ with modern type hints</li> </ul>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#complete-coverage","title":"\ud83c\udfaf Complete Coverage","text":"<ul> <li>Core Objects: User, Channel, File, and other fundamental Slack objects</li> <li>Event Models: Message, reaction, channel, and team events</li> <li>Block Kit Models: Blocks, interactive elements, and composition objects for rich messaging</li> <li>Webhook Models: Event callbacks, URL verification, and rate limiting</li> <li>Supporting Models: Reactions, message items, authorizations, and more</li> </ul>"},{"location":"#developer-friendly","title":"\ud83d\udd27 Developer Friendly","text":"<ul> <li>Type Hints: Full type annotation support with <code>py.typed</code></li> <li>Documentation: Comprehensive docstrings with Slack API references</li> <li>IDE Support: Excellent autocomplete and type checking</li> <li>Testing: Ready for comprehensive test coverage</li> </ul>"},{"location":"#modern-architecture","title":"\ud83d\ude80 Modern Architecture","text":"<ul> <li>Pydantic 2.x: Built on the latest Pydantic for performance and features</li> <li>Union Types: Type-safe event handling with discriminated unions</li> <li>Flexible Parsing: Robust parsing with the <code>parse_event</code> utility</li> <li>Standards Compliant: Strict adherence to official Slack API specifications</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from slack_models import parse_event, MessageEvent, SlackEventCallback\n\n# Parse a webhook payload\nwebhook_data = {\n    \"type\": \"event_callback\",\n    \"event\": {\n        \"type\": \"message\",\n        \"channel\": \"C1234567890\",\n        \"user\": \"U1234567890\",\n        \"text\": \"Hello, world!\",\n        \"ts\": \"1234567890.123456\"\n    }\n}\n\n# Parse and validate\nevent = parse_event(webhook_data)\nif isinstance(event, SlackEventCallback):\n    if isinstance(event.event, MessageEvent):\n        print(f\"Message: {event.event.text}\")\n        print(f\"Channel: {event.event.channel}\")\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>Install slack-models using pip:</p> <pre><code>pip install slack-models\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.12+</li> <li>pydantic &gt;=2.11.3,&lt;3</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the BSD-3-Clause License. See the LICENSE file for details.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to start using slack-models? Check out our Quick Start guide or explore the API Reference for detailed model documentation.</p>"},{"location":"#support","title":"Support","text":"<ul> <li>Documentation: https://gmr.github.io/slack-models/</li> <li>Source Code: https://github.com/gmr/slack-models</li> <li>Issues: https://github.com/gmr/slack-models/issues</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<p>slack-models requires Python 3.12 or higher and depends on Pydantic 2.x for data validation and serialization.</p>"},{"location":"installation/#system-requirements","title":"System Requirements","text":"<ul> <li>Python 3.12+</li> <li>pip (Python package installer)</li> </ul>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<p>The library has minimal dependencies:</p> <ul> <li><code>pydantic&gt;=2.11.3,&lt;3</code> - Core data validation and serialization</li> </ul>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#using-pip-recommended","title":"Using pip (Recommended)","text":"<p>Install slack-models from PyPI using pip:</p> <pre><code>pip install slack-models\n</code></pre>"},{"location":"installation/#using-pip-with-specific-version","title":"Using pip with specific version","text":"<p>To install a specific version:</p> <pre><code>pip install slack-models==1.0.0\n</code></pre>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>For development or contributing to the project:</p> <pre><code># Clone the repository\ngit clone https://github.com/gmr/slack-models.git\ncd slack-models\n\n# Install in development mode\npip install -e '.[dev]'\n\n# Install pre-commit hooks\npre-commit install\n</code></pre>"},{"location":"installation/#verification","title":"Verification","text":"<p>Verify your installation by importing the library:</p> <pre><code>import slack_models\n\n# Check the installed version\nprint(slack_models.version)\n\n# Import some models to test\nfrom slack_models import User, Channel, MessageEvent\nprint(\"Installation successful!\")\n</code></pre>"},{"location":"installation/#virtual-environment-recommended","title":"Virtual Environment (Recommended)","text":"<p>It's recommended to install slack-models in a virtual environment:</p> <pre><code># Create a virtual environment\npython -m venv slack-models-env\n\n# Activate the virtual environment\n# On Linux/macOS:\nsource slack-models-env/bin/activate\n# On Windows:\nslack-models-env\\Scripts\\activate\n\n# Install slack-models\npip install slack-models\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#python-version-issues","title":"Python Version Issues","text":"<p>If you encounter Python version compatibility issues:</p> <pre><code># Check your Python version\npython --version\n\n# Make sure you're using Python 3.12+\npython3.12 -m pip install slack-models\n</code></pre>"},{"location":"installation/#dependency-conflicts","title":"Dependency Conflicts","text":"<p>If you encounter dependency conflicts with Pydantic:</p> <pre><code># Install with specific Pydantic version\npip install slack-models pydantic&gt;=2.11.3,&lt;3\n</code></pre>"},{"location":"installation/#development-dependencies","title":"Development Dependencies","text":"<p>For development, install additional dependencies:</p> <pre><code>pip install -e '.[dev]'\n</code></pre> <p>This includes tools for: - Testing: <code>pytest</code>, <code>coverage</code> - Linting: <code>ruff</code>, <code>mypy</code> - Documentation: <code>mkdocs</code>, <code>mkdocs-material</code> - Pre-commit hooks: <code>pre-commit</code></p>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<p>Once installed, continue with the Quick Start guide to begin using slack-models in your project.</p>"},{"location":"quickstart/","title":"Quick Start","text":"<p>This guide will help you get started with slack-models quickly. We'll cover the basics of using the library to parse Slack events and work with Slack API data.</p>"},{"location":"quickstart/#basic-usage","title":"Basic Usage","text":""},{"location":"quickstart/#importing-models","title":"Importing Models","text":"<pre><code>from slack_models import (\n    User, Channel, MessageEvent,\n    SlackEventCallback, parse_event\n)\n</code></pre>"},{"location":"quickstart/#parsing-events","title":"Parsing Events","text":"<p>The <code>parse_event</code> function is the main entry point for parsing Slack webhook payloads:</p> <pre><code>from slack_models import parse_event\n\n# Example webhook payload\nwebhook_data = {\n    \"type\": \"event_callback\",\n    \"event\": {\n        \"type\": \"message\",\n        \"channel\": \"C1234567890\",\n        \"user\": \"U1234567890\",\n        \"text\": \"Hello, world!\",\n        \"ts\": \"1234567890.123456\"\n    },\n    \"team_id\": \"T1234567890\",\n    \"api_app_id\": \"A1234567890\"\n}\n\n# Parse the event\nevent = parse_event(webhook_data)\nprint(f\"Event type: {type(event).__name__}\")\n</code></pre>"},{"location":"quickstart/#working-with-specific-events","title":"Working with Specific Events","text":""},{"location":"quickstart/#message-events","title":"Message Events","text":"<pre><code>from slack_models import MessageEvent, SlackEventCallback\n\n# Parse a message event\nif isinstance(event, SlackEventCallback):\n    if isinstance(event.event, MessageEvent):\n        message = event.event\n        print(f\"Message: {message.text}\")\n        print(f\"Channel: {message.channel}\")\n        print(f\"User: {message.user}\")\n        print(f\"Timestamp: {message.ts}\")\n</code></pre>"},{"location":"quickstart/#reaction-events","title":"Reaction Events","text":"<pre><code>from slack_models import ReactionAddedEvent, ReactionRemovedEvent\n\n# Handle reaction events\nif isinstance(event, SlackEventCallback):\n    if isinstance(event.event, ReactionAddedEvent):\n        reaction = event.event\n        print(f\"Reaction added: {reaction.reaction}\")\n        print(f\"User: {reaction.user}\")\n        print(f\"Item: {reaction.item}\")\n\n    elif isinstance(event.event, ReactionRemovedEvent):\n        reaction = event.event\n        print(f\"Reaction removed: {reaction.reaction}\")\n</code></pre>"},{"location":"quickstart/#channel-events","title":"Channel Events","text":"<pre><code>from slack_models import ChannelCreatedEvent, ChannelDeletedEvent\n\n# Handle channel events\nif isinstance(event, SlackEventCallback):\n    if isinstance(event.event, ChannelCreatedEvent):\n        channel_event = event.event\n        print(f\"Channel created: {channel_event.channel.name}\")\n\n    elif isinstance(event.event, ChannelDeletedEvent):\n        channel_event = event.event\n        print(f\"Channel deleted: {channel_event.channel}\")\n</code></pre>"},{"location":"quickstart/#working-with-core-objects","title":"Working with Core Objects","text":""},{"location":"quickstart/#user-objects","title":"User Objects","text":"<pre><code>from slack_models import User\n\n# Create a user object\nuser_data = {\n    \"id\": \"U1234567890\",\n    \"name\": \"john.doe\",\n    \"real_name\": \"John Doe\",\n    \"profile\": {\n        \"email\": \"john.doe@example.com\",\n        \"display_name\": \"John\",\n        \"first_name\": \"John\",\n        \"last_name\": \"Doe\"\n    }\n}\n\nuser = User(**user_data)\nprint(f\"User: {user.name} ({user.real_name})\")\nprint(f\"Email: {user.profile.email}\")\n</code></pre>"},{"location":"quickstart/#channel-objects","title":"Channel Objects","text":"<pre><code>from slack_models import Channel\n\n# Create a channel object\nchannel_data = {\n    \"id\": \"C1234567890\",\n    \"name\": \"general\",\n    \"created\": 1234567890,\n    \"creator\": \"U1234567890\",\n    \"is_channel\": True,\n    \"is_general\": True,\n    \"is_member\": True\n}\n\nchannel = Channel(**channel_data)\nprint(f\"Channel: #{channel.name}\")\nprint(f\"Created by: {channel.creator}\")\nprint(f\"Is member: {channel.is_member}\")\n</code></pre>"},{"location":"quickstart/#error-handling","title":"Error Handling","text":"<p>slack-models uses Pydantic for validation, so you should handle validation errors:</p> <pre><code>from pydantic import ValidationError\nfrom slack_models import parse_event\n\ntry:\n    event = parse_event(webhook_data)\n    # Process the event\nexcept ValidationError as e:\n    print(f\"Validation error: {e}\")\n    # Handle invalid data\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"quickstart/#type-checking","title":"Type Checking","text":"<p>Use type checking to ensure proper handling:</p> <pre><code>from slack_models import (\n    SlackEventCallback, SlackUrlVerification,\n    SlackAppRateLimited, MessageEvent\n)\n\nevent = parse_event(webhook_data)\n\n# Type-safe event handling\nif isinstance(event, SlackEventCallback):\n    if isinstance(event.event, MessageEvent):\n        # TypeScript-style type narrowing\n        message: MessageEvent = event.event\n        print(f\"Message: {message.text}\")\n\nelif isinstance(event, SlackUrlVerification):\n    # Handle URL verification\n    print(f\"Challenge: {event.challenge}\")\n\nelif isinstance(event, SlackAppRateLimited):\n    # Handle rate limiting\n    print(f\"Rate limited for {event.minute_rate_limited} minutes\")\n</code></pre>"},{"location":"quickstart/#common-patterns","title":"Common Patterns","text":""},{"location":"quickstart/#webhook-handler","title":"Webhook Handler","text":"<pre><code>from slack_models import parse_event, SlackEventCallback, MessageEvent\n\ndef handle_webhook(payload: dict):\n    \"\"\"Handle incoming Slack webhook payload.\"\"\"\n    try:\n        event = parse_event(payload)\n\n        if isinstance(event, SlackEventCallback):\n            if isinstance(event.event, MessageEvent):\n                handle_message(event.event)\n            # Handle other event types...\n\n    except Exception as e:\n        print(f\"Error handling webhook: {e}\")\n\ndef handle_message(message: MessageEvent):\n    \"\"\"Handle a message event.\"\"\"\n    print(f\"New message in {message.channel}: {message.text}\")\n</code></pre>"},{"location":"quickstart/#event-router","title":"Event Router","text":"<pre><code>from slack_models import (\n    parse_event, SlackEventCallback,\n    MessageEvent, ReactionAddedEvent, ChannelCreatedEvent\n)\n\ndef route_event(payload: dict):\n    \"\"\"Route events to appropriate handlers.\"\"\"\n    event = parse_event(payload)\n\n    if isinstance(event, SlackEventCallback):\n        event_handlers = {\n            MessageEvent: handle_message,\n            ReactionAddedEvent: handle_reaction,\n            ChannelCreatedEvent: handle_channel_created,\n        }\n\n        handler = event_handlers.get(type(event.event))\n        if handler:\n            handler(event.event)\n        else:\n            print(f\"No handler for event type: {type(event.event)}\")\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the API Reference for detailed model documentation</li> <li>Check out Examples for more complex usage patterns</li> <li>Learn about Event Handling for comprehensive event processing</li> </ul>"},{"location":"api/models/","title":"Models API Reference","text":"<p>This page provides comprehensive documentation for all Pydantic models provided by slack-models.</p>"},{"location":"api/models/#core-models","title":"Core Models","text":""},{"location":"api/models/#user-models","title":"User Models","text":""},{"location":"api/models/#slack_models.User","title":"<code>slack_models.User</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A comprehensive representation of a Slack workspace user.</p> <p>Provides detailed information about a user within a Slack workspace, including profile details, workspace roles, and account settings. Contains workspace-specific information and may include Enterprise Grid user data. User object composition can vary and not all fields will be present for every user.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class User(pydantic.BaseModel):\n    \"\"\"A comprehensive representation of a Slack workspace user.\n\n    Provides detailed information about a user within a Slack workspace,\n    including profile details, workspace roles, and account settings.\n    Contains workspace-specific information and may include Enterprise Grid\n    user data. User object composition can vary and not all fields will be\n    present for every user.\n    \"\"\"\n\n    id: str\n    team_id: str | None = None\n    name: str | None = None\n    deleted: bool = False\n    color: str | None = None\n    real_name: str | None = None\n    tz: str | None = None\n    tz_label: str | None = None\n    tz_offset: int | None = None\n    profile: UserProfile | None = None\n    is_bot: bool = False\n    is_admin: bool = False\n    is_owner: bool = False\n    is_primary_owner: bool = False\n    is_restricted: bool = False\n    is_ultra_restricted: bool = False\n    is_app_user: bool = False\n    enterprise_user: EnterpriseUser | None = None\n    updated: int | None = None\n    is_email_confirmed: bool | None = None\n    who_can_share_contact_card: str | None = None\n\n    @property\n    def display_name(self) -&gt; str:\n        \"\"\"Return the name to display\"\"\"\n        if not self.profile:\n            return self.name or self.id\n        return (\n            self.profile.display_name\n            or self.profile.first_name\n            or self.name\n            or self.id\n        )\n</code></pre>"},{"location":"api/models/#slack_models.UserProfile","title":"<code>slack_models.UserProfile</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Contains detailed profile information for a Slack user.</p> <p>Stores both standard and custom profile fields including user status, contact information, display names, and profile images. Profile composition can vary and not all fields will be present for every user.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class UserProfile(pydantic.BaseModel):\n    \"\"\"Contains detailed profile information for a Slack user.\n\n    Stores both standard and custom profile fields including user status,\n    contact information, display names, and profile images. Profile\n    composition can vary and not all fields will be present for every user.\n    \"\"\"\n\n    title: str | None = None\n    phone: str | None = None\n    skype: str | None = None\n    email: str | None = None\n    real_name: str | None = None\n    display_name: str | None = None\n    first_name: str | None = None\n    last_name: str | None = None\n    real_name_normalized: str | None = None\n    display_name_normalized: str | None = None\n    fields: list[dict] | None = None\n    status_text: str | None = None\n    status_emoji: str | None = None\n    status_expiration: int | None = None\n    avatar_hash: str | None = None\n    always_active: bool | None = False\n    image_original: str | None = None\n    image_24: str | None = None\n    image_32: str | None = None\n    image_48: str | None = None\n    image_72: str | None = None\n    image_192: str | None = None\n    image_512: str | None = None\n    image_1024: str | None = None\n    status_text_canonical: str | None = None\n    team: str | None = None\n</code></pre>"},{"location":"api/models/#slack_models.EnterpriseUser","title":"<code>slack_models.EnterpriseUser</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Contains Enterprise Grid-specific user information.</p> <p>Provides details about a user's enterprise identity including enterprise ID, name, administrative roles, and team memberships within the Enterprise Grid structure.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class EnterpriseUser(pydantic.BaseModel):\n    \"\"\"Contains Enterprise Grid-specific user information.\n\n    Provides details about a user's enterprise identity including\n    enterprise ID, name, administrative roles, and team memberships\n    within the Enterprise Grid structure.\n    \"\"\"\n\n    enterprise_id: str\n    enterprise_name: str\n    is_admin: bool\n    is_owner: bool\n    teams: list[str] | None = None\n</code></pre>"},{"location":"api/models/#channel-models","title":"Channel Models","text":""},{"location":"api/models/#slack_models.Channel","title":"<code>slack_models.Channel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A legacy object that contains information about a workspace channel.</p> <p>Represents a communication space within Slack containing metadata like channel ID, name, creation timestamp, creator, and membership status. Includes details such as whether the channel is archived, general, shared, or private, and tracks information like last read message, unread message count, and channel topic/purpose.</p> <p>Note: This is different from private channels (which are group objects).</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class Channel(pydantic.BaseModel):\n    \"\"\"A legacy object that contains information about a workspace channel.\n\n    Represents a communication space within Slack containing metadata like\n    channel ID, name, creation timestamp, creator, and membership status.\n    Includes details such as whether the channel is archived, general,\n    shared, or private, and tracks information like last read message,\n    unread message count, and channel topic/purpose.\n\n    Note: This is different from private channels (which are group objects).\n    \"\"\"\n\n    id: str\n    name: str = ''\n    is_channel: bool | None = None\n    created: int | None = None\n    creator: str | None = None\n    is_archived: bool = False\n    is_general: bool | None = None\n    name_normalized: str | None = None\n    is_shared: bool | None = None\n    is_org_shared: bool = False\n    is_member: bool | None = None\n    is_private: bool | None = None\n    is_mpim: bool | None = None\n    is_im: bool = False\n    last_read: str | None = None\n    latest: dict | None = None\n    unread_count: int = 0\n    unread_count_display: int = 0\n    members: list[str] | None = None\n    topic: dict | None = None\n    purpose: dict | None = None\n    previous_names: list[str] | None = None\n</code></pre>"},{"location":"api/models/#file-models","title":"File Models","text":""},{"location":"api/models/#slack_models.File","title":"<code>slack_models.File</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A file object contains information about a file shared with a workspace.</p> <p>Represents a file shared within a Slack workspace, including unique identifier, creation timestamp, file metadata like name, type, and size, user who uploaded the file, sharing information, and thumbnail/preview URLs.</p> <p>Authentication is required to access file URLs.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class File(pydantic.BaseModel, extra='ignore'):\n    \"\"\"A file object contains information about a file shared with a workspace.\n\n    Represents a file shared within a Slack workspace, including unique\n    identifier, creation timestamp, file metadata like name, type, and size,\n    user who uploaded the file, sharing information, and thumbnail/preview\n    URLs.\n\n    Authentication is required to access file URLs.\n\n    \"\"\"\n\n    id: str\n    name: str\n    title: str\n    mimetype: str\n    size: int\n    mode: str\n    url_private: str\n    url_private_download: str | None = None\n</code></pre>"},{"location":"api/models/#slack_models.FileContent","title":"<code>slack_models.FileContent</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents downloaded file content with MIME type information.</p> <p>Contains the actual file data (as bytes) along with its MIME type, used for processing file attachments from Slack messages.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class FileContent(pydantic.BaseModel):\n    \"\"\"Represents downloaded file content with MIME type information.\n\n    Contains the actual file data (as bytes) along with its MIME type,\n    used for processing file attachments from Slack messages.\n    \"\"\"\n\n    mimetype: str\n    content: str | bytes\n</code></pre>"},{"location":"api/models/#block-kit-models","title":"Block Kit Models","text":""},{"location":"api/models/#composition-objects","title":"Composition Objects","text":""},{"location":"api/models/#slack_models.TextObject","title":"<code>slack_models.TextObject</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A text object for formatting text in Slack Block Kit.</p> <p>Contains formatted text with type specification for plain text or markdown rendering. Used throughout Block Kit for displaying text content with optional emoji rendering and verbatim formatting.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class TextObject(pydantic.BaseModel):\n    \"\"\"A text object for formatting text in Slack Block Kit.\n\n    Contains formatted text with type specification for plain text or\n    markdown rendering. Used throughout Block Kit for displaying text\n    content with optional emoji rendering and verbatim formatting.\n    \"\"\"\n\n    type: typing.Literal['plain_text', 'mrkdwn']\n    text: str\n    emoji: bool | None = None\n    verbatim: bool | None = None\n</code></pre>"},{"location":"api/models/#slack_models.ConfirmationDialog","title":"<code>slack_models.ConfirmationDialog</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A confirmation dialog composition object.</p> <p>Defines a dialog that provides a confirmation step for interactive elements. Contains title, explanatory text, and button labels for confirm and deny actions.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class ConfirmationDialog(pydantic.BaseModel):\n    \"\"\"A confirmation dialog composition object.\n\n    Defines a dialog that provides a confirmation step for interactive\n    elements. Contains title, explanatory text, and button labels for\n    confirm and deny actions.\n    \"\"\"\n\n    title: TextObject\n    text: TextObject\n    confirm: TextObject\n    deny: TextObject\n</code></pre>"},{"location":"api/models/#slack_models.Option","title":"<code>slack_models.Option</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>An option object for use in select menus and multi-select menus.</p> <p>Represents a single selectable option containing display text and a value. Optionally includes a description for additional context.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class Option(pydantic.BaseModel):\n    \"\"\"An option object for use in select menus and multi-select menus.\n\n    Represents a single selectable option containing display text and\n    a value. Optionally includes a description for additional context.\n    \"\"\"\n\n    text: TextObject\n    value: str\n    description: TextObject | None = None\n    url: str | None = None\n</code></pre>"},{"location":"api/models/#slack_models.OptionGroup","title":"<code>slack_models.OptionGroup</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>An option group object for organizing options in select menus.</p> <p>Groups related options together with a label for improved organization in select and multi-select menus.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class OptionGroup(pydantic.BaseModel):\n    \"\"\"An option group object for organizing options in select menus.\n\n    Groups related options together with a label for improved\n    organization in select and multi-select menus.\n    \"\"\"\n\n    label: TextObject\n    options: list[Option]\n</code></pre>"},{"location":"api/models/#block-types","title":"Block Types","text":""},{"location":"api/models/#slack_models.SectionBlock","title":"<code>slack_models.SectionBlock</code>","text":"<p>               Bases: <code>BaseBlock</code></p> <p>A section block for displaying text and interactive elements.</p> <p>Basic block for displaying text content with optional interactive element (accessory). Supports both plain text and markdown formatting with multiple text field support.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class SectionBlock(BaseBlock):\n    \"\"\"A section block for displaying text and interactive elements.\n\n    Basic block for displaying text content with optional interactive\n    element (accessory). Supports both plain text and markdown formatting\n    with multiple text field support.\n    \"\"\"\n\n    type: typing.Literal['section'] = 'section'\n    text: TextObject | None = None\n    fields: list[TextObject] | None = None\n    accessory: BlockElement | None = None\n</code></pre>"},{"location":"api/models/#slack_models.DividerBlock","title":"<code>slack_models.DividerBlock</code>","text":"<p>               Bases: <code>BaseBlock</code></p> <p>A divider block for visual separation.</p> <p>Simple block that displays a horizontal line to visually separate content sections. Requires no additional configuration.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class DividerBlock(BaseBlock):\n    \"\"\"A divider block for visual separation.\n\n    Simple block that displays a horizontal line to visually separate\n    content sections. Requires no additional configuration.\n    \"\"\"\n\n    type: typing.Literal['divider'] = 'divider'\n</code></pre>"},{"location":"api/models/#slack_models.ImageBlock","title":"<code>slack_models.ImageBlock</code>","text":"<p>               Bases: <code>BaseBlock</code></p> <p>An image block for displaying images.</p> <p>Displays an image with title and alternative text for accessibility. Images must be publicly accessible or use Slack-hosted URLs.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class ImageBlock(BaseBlock):\n    \"\"\"An image block for displaying images.\n\n    Displays an image with title and alternative text for accessibility.\n    Images must be publicly accessible or use Slack-hosted URLs.\n    \"\"\"\n\n    type: typing.Literal['image'] = 'image'\n    image_url: str\n    alt_text: str\n    title: TextObject | None = None\n</code></pre>"},{"location":"api/models/#slack_models.ActionsBlock","title":"<code>slack_models.ActionsBlock</code>","text":"<p>               Bases: <code>BaseBlock</code></p> <p>An actions block for interactive elements.</p> <p>Container for interactive elements like buttons, select menus, and other input elements. Can hold up to 25 elements in a horizontal layout.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class ActionsBlock(BaseBlock):\n    \"\"\"An actions block for interactive elements.\n\n    Container for interactive elements like buttons, select menus,\n    and other input elements. Can hold up to 25 elements in a\n    horizontal layout.\n    \"\"\"\n\n    type: typing.Literal['actions'] = 'actions'\n    elements: list[BlockElement]\n</code></pre>"},{"location":"api/models/#slack_models.ContextBlock","title":"<code>slack_models.ContextBlock</code>","text":"<p>               Bases: <code>BaseBlock</code></p> <p>A context block for supplementary information.</p> <p>Displays contextual information using small text and images. Useful for metadata, timestamps, and supplementary details.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class ContextBlock(BaseBlock):\n    \"\"\"A context block for supplementary information.\n\n    Displays contextual information using small text and images.\n    Useful for metadata, timestamps, and supplementary details.\n    \"\"\"\n\n    type: typing.Literal['context'] = 'context'\n    elements: list[TextObject | ImageElement]\n</code></pre>"},{"location":"api/models/#slack_models.InputBlock","title":"<code>slack_models.InputBlock</code>","text":"<p>               Bases: <code>BaseBlock</code></p> <p>An input block for collecting user input.</p> <p>Contains a single input element with label and optional hint text. Used in modals and app home surfaces for form-like interactions.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class InputBlock(BaseBlock):\n    \"\"\"An input block for collecting user input.\n\n    Contains a single input element with label and optional hint text.\n    Used in modals and app home surfaces for form-like interactions.\n    \"\"\"\n\n    type: typing.Literal['input'] = 'input'\n    label: TextObject\n    element: BlockElement\n    hint: TextObject | None = None\n    optional: bool | None = None\n    dispatch_action: bool | None = None\n</code></pre>"},{"location":"api/models/#slack_models.HeaderBlock","title":"<code>slack_models.HeaderBlock</code>","text":"<p>               Bases: <code>BaseBlock</code></p> <p>A header block for section titles.</p> <p>Displays large text intended as a section header. Text is always rendered in plain text format for consistent styling.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class HeaderBlock(BaseBlock):\n    \"\"\"A header block for section titles.\n\n    Displays large text intended as a section header. Text is always\n    rendered in plain text format for consistent styling.\n    \"\"\"\n\n    type: typing.Literal['header'] = 'header'\n    text: TextObject\n</code></pre>"},{"location":"api/models/#slack_models.VideoBlock","title":"<code>slack_models.VideoBlock</code>","text":"<p>               Bases: <code>BaseBlock</code></p> <p>A video block for embedding video content.</p> <p>Embeds video content from supported platforms with metadata including title, description, and provider information.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class VideoBlock(BaseBlock):\n    \"\"\"A video block for embedding video content.\n\n    Embeds video content from supported platforms with metadata\n    including title, description, and provider information.\n    \"\"\"\n\n    type: typing.Literal['video'] = 'video'\n    video_url: str\n    thumbnail_url: str\n    alt_text: str\n    title: TextObject\n    title_url: str | None = None\n    description: TextObject | None = None\n    provider_icon_url: str | None = None\n    provider_name: str | None = None\n</code></pre>"},{"location":"api/models/#slack_models.RichTextBlock","title":"<code>slack_models.RichTextBlock</code>","text":"<p>               Bases: <code>BaseBlock</code></p> <p>A rich text block for complex text formatting.</p> <p>Supports advanced text formatting including lists, quotes, preformatted text, and inline formatting like bold, italic, and links.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class RichTextBlock(BaseBlock):\n    \"\"\"A rich text block for complex text formatting.\n\n    Supports advanced text formatting including lists, quotes,\n    preformatted text, and inline formatting like bold, italic,\n    and links.\n    \"\"\"\n\n    type: typing.Literal['rich_text'] = 'rich_text'\n    elements: list[\n        RichTextSection | RichTextList | RichTextQuote | RichTextPreformatted\n    ]\n</code></pre>"},{"location":"api/models/#slack_models.FileBlock","title":"<code>slack_models.FileBlock</code>","text":"<p>               Bases: <code>BaseBlock</code></p> <p>A file block for displaying Slack files.</p> <p>Displays information about a Slack file including thumbnail, title, and metadata. Files must be shared in the workspace.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class FileBlock(BaseBlock):\n    \"\"\"A file block for displaying Slack files.\n\n    Displays information about a Slack file including thumbnail,\n    title, and metadata. Files must be shared in the workspace.\n    \"\"\"\n\n    type: typing.Literal['file'] = 'file'\n    external_id: str\n    source: typing.Literal['remote'] = 'remote'\n</code></pre>"},{"location":"api/models/#block-elements","title":"Block Elements","text":""},{"location":"api/models/#slack_models.ButtonElement","title":"<code>slack_models.ButtonElement</code>","text":"<p>               Bases: <code>BaseBlockElement</code></p> <p>A button element for user interaction.</p> <p>Interactive element that triggers an action when clicked. Can be styled as primary, danger, or default, and may include a URL for navigation or confirmation dialog for safety.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class ButtonElement(BaseBlockElement):\n    \"\"\"A button element for user interaction.\n\n    Interactive element that triggers an action when clicked. Can be\n    styled as primary, danger, or default, and may include a URL for\n    navigation or confirmation dialog for safety.\n    \"\"\"\n\n    type: typing.Literal['button'] = 'button'\n    text: TextObject\n    value: str | None = None\n    url: str | None = None\n    style: typing.Literal['primary', 'danger'] | None = None\n    confirm: ConfirmationDialog | None = None\n</code></pre>"},{"location":"api/models/#slack_models.StaticSelectElement","title":"<code>slack_models.StaticSelectElement</code>","text":"<p>               Bases: <code>BaseBlockElement</code></p> <p>A static select menu with predefined options.</p> <p>Select menu populated with a static list of options or option groups. Supports single selection with optional initial selection and confirmation dialog.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class StaticSelectElement(BaseBlockElement):\n    \"\"\"A static select menu with predefined options.\n\n    Select menu populated with a static list of options or option groups.\n    Supports single selection with optional initial selection and\n    confirmation dialog.\n    \"\"\"\n\n    type: typing.Literal['static_select'] = 'static_select'\n    placeholder: TextObject\n    options: list[Option] | None = None\n    option_groups: list[OptionGroup] | None = None\n    initial_option: Option | None = None\n    confirm: ConfirmationDialog | None = None\n    focus_on_load: bool | None = None\n</code></pre>"},{"location":"api/models/#slack_models.CheckboxesElement","title":"<code>slack_models.CheckboxesElement</code>","text":"<p>               Bases: <code>BaseBlockElement</code></p> <p>A checkboxes element for multiple selections.</p> <p>Allows users to select multiple options from a list of checkboxes. Can have initial options selected and includes confirmation dialog support for safety.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class CheckboxesElement(BaseBlockElement):\n    \"\"\"A checkboxes element for multiple selections.\n\n    Allows users to select multiple options from a list of checkboxes.\n    Can have initial options selected and includes confirmation dialog\n    support for safety.\n    \"\"\"\n\n    type: typing.Literal['checkboxes'] = 'checkboxes'\n    options: list[Option]\n    initial_options: list[Option] | None = None\n    confirm: ConfirmationDialog | None = None\n    focus_on_load: bool | None = None\n</code></pre>"},{"location":"api/models/#slack_models.DatePickerElement","title":"<code>slack_models.DatePickerElement</code>","text":"<p>               Bases: <code>BaseBlockElement</code></p> <p>A date picker element for selecting dates.</p> <p>Provides a calendar interface for users to select a date. Can have an initial date set and includes placeholder text and confirmation dialog support.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class DatePickerElement(BaseBlockElement):\n    \"\"\"A date picker element for selecting dates.\n\n    Provides a calendar interface for users to select a date.\n    Can have an initial date set and includes placeholder text\n    and confirmation dialog support.\n    \"\"\"\n\n    type: typing.Literal['datepicker'] = 'datepicker'\n    initial_date: str | None = None\n    confirm: ConfirmationDialog | None = None\n    focus_on_load: bool | None = None\n    placeholder: TextObject | None = None\n</code></pre>"},{"location":"api/models/#slack_models.PlainTextInputElement","title":"<code>slack_models.PlainTextInputElement</code>","text":"<p>               Bases: <code>BaseBlockElement</code></p> <p>A plain text input element for collecting text input.</p> <p>Basic text input field with support for single or multi-line input, length constraints, and input validation through dispatch actions.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class PlainTextInputElement(BaseBlockElement):\n    \"\"\"A plain text input element for collecting text input.\n\n    Basic text input field with support for single or multi-line input,\n    length constraints, and input validation through dispatch actions.\n    \"\"\"\n\n    type: typing.Literal['plain_text_input'] = 'plain_text_input'\n    placeholder: TextObject | None = None\n    initial_value: str | None = None\n    multiline: bool | None = None\n    min_length: int | None = None\n    max_length: int | None = None\n    dispatch_action_config: dict | None = None\n    focus_on_load: bool | None = None\n</code></pre>"},{"location":"api/models/#slack_models.ImageElement","title":"<code>slack_models.ImageElement</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>An image element for displaying images in blocks.</p> <p>Displays an image with alternative text for accessibility. Can be used in various block types to enhance visual content.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class ImageElement(pydantic.BaseModel):\n    \"\"\"An image element for displaying images in blocks.\n\n    Displays an image with alternative text for accessibility.\n    Can be used in various block types to enhance visual content.\n    \"\"\"\n\n    type: typing.Literal['image'] = 'image'\n    image_url: str\n    alt_text: str\n</code></pre>"},{"location":"api/models/#rich-text-elements","title":"Rich Text Elements","text":""},{"location":"api/models/#slack_models.RichTextSection","title":"<code>slack_models.RichTextSection</code>","text":"<p>               Bases: <code>RichTextElement</code></p> <p>A rich text section containing formatted text elements.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class RichTextSection(RichTextElement):\n    \"\"\"A rich text section containing formatted text elements.\"\"\"\n\n    type: typing.Literal['rich_text_section'] = 'rich_text_section'\n    elements: list[dict]\n</code></pre>"},{"location":"api/models/#slack_models.RichTextList","title":"<code>slack_models.RichTextList</code>","text":"<p>               Bases: <code>RichTextElement</code></p> <p>A rich text list (ordered or unordered).</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class RichTextList(RichTextElement):\n    \"\"\"A rich text list (ordered or unordered).\"\"\"\n\n    type: typing.Literal['rich_text_list'] = 'rich_text_list'\n    style: typing.Literal['ordered', 'bullet']\n    elements: list[dict]\n    indent: int | None = None\n    border: int | None = None\n</code></pre>"},{"location":"api/models/#slack_models.RichTextQuote","title":"<code>slack_models.RichTextQuote</code>","text":"<p>               Bases: <code>RichTextElement</code></p> <p>A rich text quote block.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class RichTextQuote(RichTextElement):\n    \"\"\"A rich text quote block.\"\"\"\n\n    type: typing.Literal['rich_text_quote'] = 'rich_text_quote'\n    elements: list[dict]\n    border: int | None = None\n</code></pre>"},{"location":"api/models/#slack_models.RichTextPreformatted","title":"<code>slack_models.RichTextPreformatted</code>","text":"<p>               Bases: <code>RichTextElement</code></p> <p>A rich text preformatted block.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class RichTextPreformatted(RichTextElement):\n    \"\"\"A rich text preformatted block.\"\"\"\n\n    type: typing.Literal['rich_text_preformatted'] = 'rich_text_preformatted'\n    elements: list[dict]\n    border: int | None = None\n</code></pre>"},{"location":"api/models/#event-models","title":"Event Models","text":""},{"location":"api/models/#message-events","title":"Message Events","text":""},{"location":"api/models/#slack_models.MessageEvent","title":"<code>slack_models.MessageEvent</code>","text":"<p>               Bases: <code>BaseSlackEvent</code></p> <p>A message was sent to a channel.</p> <p>Delivered when a message is posted to a channel, containing details like channel ID, user ID, message text, and timestamp. Can have various subtypes and may include additional properties like stars, pins, reactions, and file attachments.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class MessageEvent(BaseSlackEvent):\n    \"\"\"A message was sent to a channel.\n\n    Delivered when a message is posted to a channel, containing details\n    like channel ID, user ID, message text, and timestamp. Can have\n    various subtypes and may include additional properties like stars,\n    pins, reactions, and file attachments.\n    \"\"\"\n\n    type: typing.Literal['message'] = 'message'\n    ts: str\n    channel: str | None = None\n    text: str | None = None\n    user: str | None = None\n    thread_ts: str | None = None\n    subtype: str | None = None\n    bot_id: str | None = None\n    blocks: list[Block] | None = None\n    channel_type: str | None = None\n    edited: MessageEdited | None = None\n    files: list[File] | None = None\n    message: typing.Self | None = None\n    reactions: list[Reaction] | None = None\n    is_starred: bool | None = None\n    pinned_to: list[str] | None = None\n    parent_user_id: str | None = None\n    reply_count: int | None = None\n    reply_users: list[str] | None = None\n    reply_users_count: int | None = None\n    latest_reply: str | None = None\n    hidden: bool | None = None\n    deleted_ts: str | None = None\n</code></pre>"},{"location":"api/models/#slack_models.MessageItem","title":"<code>slack_models.MessageItem</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents an item referenced in a Slack event.</p> <p>Used in reaction events to identify the target item (message, file, or file comment) that was reacted to. Contains the item type, channel/location, and timestamp information.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class MessageItem(pydantic.BaseModel):\n    \"\"\"Represents an item referenced in a Slack event.\n\n    Used in reaction events to identify the target item (message, file,\n    or file comment) that was reacted to. Contains the item type,\n    channel/location, and timestamp information.\n    \"\"\"\n\n    type: str = 'message'\n    channel: str\n    ts: str\n    thread_ts: str | None = None\n</code></pre>"},{"location":"api/models/#slack_models.MessageEdited","title":"<code>slack_models.MessageEdited</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Contains metadata about a message edit.</p> <p>Tracks who edited the message and when the edit occurred, used in message events to indicate post-creation modifications.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class MessageEdited(pydantic.BaseModel):\n    \"\"\"Contains metadata about a message edit.\n\n    Tracks who edited the message and when the edit occurred,\n    used in message events to indicate post-creation modifications.\n    \"\"\"\n\n    user: str\n    ts: str\n</code></pre>"},{"location":"api/models/#slack_models.AppMentionEvent","title":"<code>slack_models.AppMentionEvent</code>","text":"<p>               Bases: <code>BaseSlackEvent</code></p> <p>Subscribe to message events that directly mention your app.</p> <p>Allows a Slack app to receive messages where the app is explicitly mentioned. Requires the app_mentions:read scope and only includes messages where the app is directly mentioned, not direct messages to the app.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class AppMentionEvent(BaseSlackEvent):\n    \"\"\"Subscribe to message events that directly mention your app.\n\n    Allows a Slack app to receive messages where the app is explicitly\n    mentioned. Requires the app_mentions:read scope and only includes\n    messages where the app is directly mentioned, not direct messages\n    to the app.\n    \"\"\"\n\n    type: typing.Literal['app_mention'] = 'app_mention'\n    channel: str\n    user: str\n    text: str\n    ts: str\n    thread_ts: str | None = None\n    event_ts: str\n</code></pre>"},{"location":"api/models/#reaction-events","title":"Reaction Events","text":""},{"location":"api/models/#slack_models.ReactionAddedEvent","title":"<code>slack_models.ReactionAddedEvent</code>","text":"<p>               Bases: <code>BaseSlackEvent</code></p> <p>A member has added an emoji reaction to an item.</p> <p>Sent when a user adds an emoji reaction to a message, file, or other item. Includes details about who added the reaction, what emoji was used, and which item was reacted to. Requires the reactions:read scope.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class ReactionAddedEvent(BaseSlackEvent):\n    \"\"\"A member has added an emoji reaction to an item.\n\n    Sent when a user adds an emoji reaction to a message, file, or other\n    item. Includes details about who added the reaction, what emoji was\n    used, and which item was reacted to. Requires the reactions:read scope.\n    \"\"\"\n\n    type: typing.Literal['reaction_added'] = 'reaction_added'\n    user: str\n    reaction: str\n    item: MessageItem\n    item_user: str | None = None\n    event_ts: str\n</code></pre>"},{"location":"api/models/#slack_models.ReactionRemovedEvent","title":"<code>slack_models.ReactionRemovedEvent</code>","text":"<p>               Bases: <code>BaseSlackEvent</code></p> <p>A reaction is removed from an item.</p> <p>Triggered when a user removes an emoji reaction from a message, file, or other item. Includes details about who removed the reaction, what emoji was removed, and which item was affected. Requires the reactions:read scope.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class ReactionRemovedEvent(BaseSlackEvent):\n    \"\"\"A reaction is removed from an item.\n\n    Triggered when a user removes an emoji reaction from a message, file,\n    or other item. Includes details about who removed the reaction, what\n    emoji was removed, and which item was affected. Requires the\n    reactions:read scope.\n    \"\"\"\n\n    type: typing.Literal['reaction_removed'] = 'reaction_removed'\n    user: str\n    reaction: str\n    item: MessageItem\n    item_user: str | None = None\n    event_ts: str\n</code></pre>"},{"location":"api/models/#slack_models.Reaction","title":"<code>slack_models.Reaction</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents an emoji reaction on a Slack message.</p> <p>Contains the reaction emoji name, count of users who reacted, and list of user IDs who added this reaction to the message.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class Reaction(pydantic.BaseModel):\n    \"\"\"Represents an emoji reaction on a Slack message.\n\n    Contains the reaction emoji name, count of users who reacted,\n    and list of user IDs who added this reaction to the message.\n    \"\"\"\n\n    name: str\n    count: int\n    users: list[str]\n</code></pre>"},{"location":"api/models/#channel-events","title":"Channel Events","text":""},{"location":"api/models/#slack_models.ChannelCreatedEvent","title":"<code>slack_models.ChannelCreatedEvent</code>","text":"<p>               Bases: <code>BaseSlackEvent</code></p> <p>A channel was created.</p> <p>Sent when a new channel is created in a workspace to help clients update their local cache of non-joined channels. Includes channel metadata such as ID, name, creation timestamp, and creator. Requires the channels:read scope.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class ChannelCreatedEvent(BaseSlackEvent):\n    \"\"\"A channel was created.\n\n    Sent when a new channel is created in a workspace to help clients\n    update their local cache of non-joined channels. Includes channel\n    metadata such as ID, name, creation timestamp, and creator.\n    Requires the channels:read scope.\n    \"\"\"\n\n    type: typing.Literal['channel_created'] = 'channel_created'\n    channel: dict  # Full channel object\n    event_ts: str\n</code></pre>"},{"location":"api/models/#slack_models.ChannelDeletedEvent","title":"<code>slack_models.ChannelDeletedEvent</code>","text":"<p>               Bases: <code>BaseSlackEvent</code></p> <p>A channel was deleted.</p> <p>Sent to all connections for a workspace when a channel is deleted to help clients update their local cache of non-joined channels. Contains the deleted channel's ID. Requires the channels:read scope.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class ChannelDeletedEvent(BaseSlackEvent):\n    \"\"\"A channel was deleted.\n\n    Sent to all connections for a workspace when a channel is deleted\n    to help clients update their local cache of non-joined channels.\n    Contains the deleted channel's ID. Requires the channels:read scope.\n    \"\"\"\n\n    type: typing.Literal['channel_deleted'] = 'channel_deleted'\n    channel: str  # Channel ID\n    event_ts: str\n</code></pre>"},{"location":"api/models/#slack_models.ChannelRenameEvent","title":"<code>slack_models.ChannelRenameEvent</code>","text":"<p>               Bases: <code>BaseSlackEvent</code></p> <p>A channel was renamed.</p> <p>Sent to all workspace connections when a channel is renamed, allowing clients to update their local list of channels. Contains the channel's new ID, name, and creation timestamp. Requires the channels:read scope.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class ChannelRenameEvent(BaseSlackEvent):\n    \"\"\"A channel was renamed.\n\n    Sent to all workspace connections when a channel is renamed,\n    allowing clients to update their local list of channels.\n    Contains the channel's new ID, name, and creation timestamp.\n    Requires the channels:read scope.\n    \"\"\"\n\n    type: typing.Literal['channel_rename'] = 'channel_rename'\n    channel: dict  # Channel object with new name\n    event_ts: str\n</code></pre>"},{"location":"api/models/#team-events","title":"Team Events","text":""},{"location":"api/models/#slack_models.TeamJoinEvent","title":"<code>slack_models.TeamJoinEvent</code>","text":"<p>               Bases: <code>BaseSlackEvent</code></p> <p>A new member has joined the team.</p> <p>Sent to all connections for a workspace when a new member joins, helping clients update their local cache of members. Includes user object with details about the new team member. Requires the users:read scope.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class TeamJoinEvent(BaseSlackEvent):\n    \"\"\"A new member has joined the team.\n\n    Sent to all connections for a workspace when a new member joins,\n    helping clients update their local cache of members. Includes\n    user object with details about the new team member. Requires\n    the users:read scope.\n    \"\"\"\n\n    type: typing.Literal['team_join'] = 'team_join'\n    user: User  # Full user object - override base class string type\n    event_ts: str\n</code></pre>"},{"location":"api/models/#file-events","title":"File Events","text":""},{"location":"api/models/#slack_models.FileCreatedEvent","title":"<code>slack_models.FileCreatedEvent</code>","text":"<p>               Bases: <code>BaseSlackEvent</code></p> <p>A file was created.</p> <p>Sent when a user uploads a file to Slack. Contains file details and user information. When a file is shared with workspace members, a separate file_shared event is also sent. Requires the files:read scope.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class FileCreatedEvent(BaseSlackEvent):\n    \"\"\"A file was created.\n\n    Sent when a user uploads a file to Slack. Contains file details\n    and user information. When a file is shared with workspace members,\n    a separate file_shared event is also sent. Requires the files:read\n    scope.\n    \"\"\"\n\n    type: typing.Literal['file_created'] = 'file_created'\n    file_id: str\n    file: dict  # Full file object\n    user_id: str\n    event_ts: str\n</code></pre>"},{"location":"api/models/#slack_models.FileDeletedEvent","title":"<code>slack_models.FileDeletedEvent</code>","text":"<p>               Bases: <code>BaseSlackEvent</code></p> <p>A file was deleted.</p> <p>Sent to all connected clients in a workspace when a file is deleted. Contains only the file ID, not a full file object. Not raised if file removal is due to workspace's file retention policy. Requires the files:read scope.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class FileDeletedEvent(BaseSlackEvent):\n    \"\"\"A file was deleted.\n\n    Sent to all connected clients in a workspace when a file is deleted.\n    Contains only the file ID, not a full file object. Not raised if\n    file removal is due to workspace's file retention policy. Requires\n    the files:read scope.\n    \"\"\"\n\n    type: typing.Literal['file_deleted'] = 'file_deleted'\n    file_id: str\n    user_id: str\n    event_ts: str\n</code></pre>"},{"location":"api/models/#webhook-models","title":"Webhook Models","text":""},{"location":"api/models/#event-callbacks","title":"Event Callbacks","text":""},{"location":"api/models/#slack_models.SlackEventCallback","title":"<code>slack_models.SlackEventCallback</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Event callback payload from Slack Events API.</p> <p>Standard envelope for event notifications sent via HTTP endpoint. Contains authentication token, workspace identifier, app identifier, event details, and authorization context. Events are delivered with a 3-second response timeout and include retry mechanisms.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class SlackEventCallback(pydantic.BaseModel):\n    \"\"\"Event callback payload from Slack Events API.\n\n    Standard envelope for event notifications sent via HTTP endpoint.\n    Contains authentication token, workspace identifier, app identifier,\n    event details, and authorization context. Events are delivered with\n    a 3-second response timeout and include retry mechanisms.\n    \"\"\"\n\n    token: str\n    team_id: str\n    api_app_id: str\n    event: SlackEvent\n    type: typing.Literal['event_callback'] = 'event_callback'\n    event_id: str\n    event_time: int\n    event_context: str | None = None\n    authorizations: list[Authorization] | None = None\n\n    model_config = pydantic.ConfigDict(extra='allow')\n</code></pre>"},{"location":"api/models/#slack_models.BaseSlackEvent","title":"<code>slack_models.BaseSlackEvent</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for all Slack event types.</p> <p>Contains common fields shared across all Slack events including event type, timestamp, and event timestamp. All specific event types inherit from this base class.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class BaseSlackEvent(pydantic.BaseModel):\n    \"\"\"Base class for all Slack event types.\n\n    Contains common fields shared across all Slack events including\n    event type, timestamp, and event timestamp.\n    All specific event types inherit from this base class.\n    \"\"\"\n\n    type: str\n    ts: str | None = None\n    event_ts: str | None = None\n</code></pre>"},{"location":"api/models/#verification-and-rate-limiting","title":"Verification and Rate Limiting","text":""},{"location":"api/models/#slack_models.SlackUrlVerification","title":"<code>slack_models.SlackUrlVerification</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>URL verification challenge from Slack.</p> <p>Sent during Events API endpoint setup to verify endpoint ownership. Contains a challenge string that must be echoed back in the response to complete the verification process.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class SlackUrlVerification(pydantic.BaseModel):\n    \"\"\"URL verification challenge from Slack.\n\n    Sent during Events API endpoint setup to verify endpoint ownership.\n    Contains a challenge string that must be echoed back in the response\n    to complete the verification process.\n    \"\"\"\n\n    token: str\n    challenge: str\n    type: typing.Literal['url_verification'] = 'url_verification'\n</code></pre>"},{"location":"api/models/#slack_models.SlackAppRateLimited","title":"<code>slack_models.SlackAppRateLimited</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>App rate limited notification from Slack.</p> <p>Sent when an app exceeds the Events API rate limit of 30,000 events per workspace per hour. Contains the minute-based rate limit count and workspace/app identifiers.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class SlackAppRateLimited(pydantic.BaseModel):\n    \"\"\"App rate limited notification from Slack.\n\n    Sent when an app exceeds the Events API rate limit of 30,000 events\n    per workspace per hour. Contains the minute-based rate limit count\n    and workspace/app identifiers.\n    \"\"\"\n\n    token: str\n    team_id: str\n    minute_rate_limited: int\n    api_app_id: str\n    type: typing.Literal['app_rate_limited'] = 'app_rate_limited'\n</code></pre>"},{"location":"api/models/#supporting-models","title":"Supporting Models","text":""},{"location":"api/models/#authorization","title":"Authorization","text":""},{"location":"api/models/#slack_models.Authorization","title":"<code>slack_models.Authorization</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Contains authorization information for a Slack webhook event.</p> <p>Provides details about the app installation including enterprise ID, team ID, user ID, and installation type. Used by Events API to identify the authorization context for the event.</p> Source code in <code>src/slack_models/_models.py</code> <pre><code>class Authorization(pydantic.BaseModel):\n    \"\"\"Contains authorization information for a Slack webhook event.\n\n    Provides details about the app installation including enterprise ID,\n    team ID, user ID, and installation type. Used by Events API to\n    identify the authorization context for the event.\n    \"\"\"\n\n    enterprise_id: str | None = None\n    team_id: str\n    user_id: str\n    is_bot: bool\n    is_enterprise_install: bool\n</code></pre>"},{"location":"api/models/#union-types","title":"Union Types","text":""},{"location":"api/models/#slackevent","title":"SlackEvent","text":"<p>A union type representing all possible Slack event types:</p> <pre><code>SlackEvent = Union[\n    MessageEvent,\n    AppMentionEvent,\n    ReactionAddedEvent,\n    ReactionRemovedEvent,\n    TeamJoinEvent,\n    FileCreatedEvent,\n    FileDeletedEvent,\n    ChannelCreatedEvent,\n    ChannelDeletedEvent,\n    ChannelRenameEvent,\n]\n</code></pre>"},{"location":"api/models/#slackwebhookpayload","title":"SlackWebhookPayload","text":"<p>A union type representing all possible webhook payload types:</p> <pre><code>SlackWebhookPayload = Union[\n    SlackEventCallback,\n    SlackUrlVerification,\n    SlackAppRateLimited,\n]\n</code></pre>"},{"location":"api/models/#model-relationships","title":"Model Relationships","text":""},{"location":"api/models/#event-hierarchy","title":"Event Hierarchy","text":"<pre><code>BaseSlackEvent\n\u251c\u2500\u2500 MessageEvent\n\u251c\u2500\u2500 AppMentionEvent\n\u251c\u2500\u2500 ReactionAddedEvent\n\u251c\u2500\u2500 ReactionRemovedEvent\n\u251c\u2500\u2500 TeamJoinEvent\n\u251c\u2500\u2500 FileCreatedEvent\n\u251c\u2500\u2500 FileDeletedEvent\n\u251c\u2500\u2500 ChannelCreatedEvent\n\u251c\u2500\u2500 ChannelDeletedEvent\n\u2514\u2500\u2500 ChannelRenameEvent\n</code></pre>"},{"location":"api/models/#webhook-payload-structure","title":"Webhook Payload Structure","text":"<pre><code>SlackWebhookPayload\n\u251c\u2500\u2500 SlackEventCallback\n\u2502   \u251c\u2500\u2500 event: SlackEvent\n\u2502   \u251c\u2500\u2500 team_id: str\n\u2502   \u2514\u2500\u2500 api_app_id: str\n\u251c\u2500\u2500 SlackUrlVerification\n\u2502   \u251c\u2500\u2500 challenge: str\n\u2502   \u2514\u2500\u2500 type: Literal[\"url_verification\"]\n\u2514\u2500\u2500 SlackAppRateLimited\n    \u251c\u2500\u2500 minute_rate_limited: int\n    \u2514\u2500\u2500 type: Literal[\"app_rate_limited\"]\n</code></pre>"},{"location":"api/models/#usage-examples","title":"Usage Examples","text":""},{"location":"api/models/#type-safe-event-handling","title":"Type-Safe Event Handling","text":"<pre><code>from slack_models import parse_event, SlackEventCallback, MessageEvent\n\ndef handle_event(payload: dict):\n    event = parse_event(payload)\n\n    if isinstance(event, SlackEventCallback):\n        if isinstance(event.event, MessageEvent):\n            # TypeScript-style type narrowing\n            message: MessageEvent = event.event\n            print(f\"Message: {message.text}\")\n</code></pre>"},{"location":"api/models/#working-with-union-types","title":"Working with Union Types","text":"<pre><code>from slack_models import SlackEvent, MessageEvent, ReactionAddedEvent\n\ndef process_event(event: SlackEvent):\n    if isinstance(event, MessageEvent):\n        print(f\"Message: {event.text}\")\n    elif isinstance(event, ReactionAddedEvent):\n        print(f\"Reaction: {event.reaction}\")\n</code></pre>"},{"location":"api/models/#channel-objects","title":"Channel Objects","text":"<pre><code>from slack_models import Channel\n\n# Standard Slack channel\nchannel = Channel(\n    id=\"C1234567890\",\n    name=\"general\",\n    is_channel=True,\n    created=1640995200,\n    creator=\"U1234567890\",\n    is_archived=False,\n    is_general=True,\n    is_member=True\n)\n\nprint(f\"Channel: #{channel.name}\")\nprint(f\"Is general channel: {channel.is_general}\")\n</code></pre>"},{"location":"api/utils/","title":"Utilities API Reference","text":"<p>This page provides documentation for utility functions provided by slack-models.</p>"},{"location":"api/utils/#event-parsing","title":"Event Parsing","text":""},{"location":"api/utils/#parse_event","title":"parse_event","text":"<p>The <code>parse_event</code> function is the main utility for parsing Slack webhook payloads into typed Pydantic models.</p>"},{"location":"api/utils/#slack_models.parse_event","title":"<code>slack_models.parse_event(event)</code>","text":"<p>Build a Pydantic model from a Slack event dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>dict</code> <p>Raw Slack event dictionary</p> required <p>Returns:</p> Type Description <code>SlackEvent</code> <p>Parsed Slack event model</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If event cannot be parsed</p> <code>ValueError</code> <p>If event type is unknown</p> Source code in <code>src/slack_models/_utils.py</code> <pre><code>def parse_event(event: dict) -&gt; _models.SlackEvent:\n    \"\"\"Build a Pydantic model from a Slack event dictionary.\n\n    Args:\n        event: Raw Slack event dictionary\n\n    Returns:\n        Parsed Slack event model\n\n    Raises:\n        pydantic.ValidationError: If event cannot be parsed\n        ValueError: If event type is unknown\n\n    \"\"\"\n    event_type = event.get('type')\n    if event_type is None:\n        raise ValueError('Event type is missing')\n    model_class = _models.EVENT_MAP.get(event_type)\n    if not model_class:\n        raise ValueError(f'Unknown event type: {event_type}')\n    return model_class.model_validate(event)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"api/utils/#usage-examples","title":"Usage Examples","text":""},{"location":"api/utils/#basic-event-parsing","title":"Basic Event Parsing","text":"<pre><code>from slack_models import parse_event\n\n# Example webhook payload\nwebhook_data = {\n    \"type\": \"event_callback\",\n    \"event\": {\n        \"type\": \"message\",\n        \"channel\": \"C1234567890\",\n        \"user\": \"U1234567890\",\n        \"text\": \"Hello, world!\",\n        \"ts\": \"1234567890.123456\"\n    },\n    \"team_id\": \"T1234567890\",\n    \"api_app_id\": \"A1234567890\"\n}\n\n# Parse the event\nevent = parse_event(webhook_data)\nprint(f\"Parsed event type: {type(event).__name__}\")\n</code></pre>"},{"location":"api/utils/#url-verification","title":"URL Verification","text":"<pre><code>from slack_models import parse_event, SlackUrlVerification\n\n# URL verification payload\nverification_data = {\n    \"type\": \"url_verification\",\n    \"challenge\": \"3eZbrw1aBm2rZgRNFdxV2595E9CY3gmdALWMmHkvFXO7tYXAYM8P\"\n}\n\nevent = parse_event(verification_data)\nif isinstance(event, SlackUrlVerification):\n    print(f\"Challenge: {event.challenge}\")\n</code></pre>"},{"location":"api/utils/#rate-limiting","title":"Rate Limiting","text":"<pre><code>from slack_models import parse_event, SlackAppRateLimited\n\n# Rate limiting payload\nrate_limit_data = {\n    \"type\": \"app_rate_limited\",\n    \"minute_rate_limited\": 1\n}\n\nevent = parse_event(rate_limit_data)\nif isinstance(event, SlackAppRateLimited):\n    print(f\"Rate limited for {event.minute_rate_limited} minutes\")\n</code></pre>"},{"location":"api/utils/#error-handling","title":"Error Handling","text":"<pre><code>from pydantic import ValidationError\nfrom slack_models import parse_event\n\ntry:\n    event = parse_event(webhook_data)\n    # Process the event\nexcept ValidationError as e:\n    print(f\"Validation error: {e}\")\n    # Handle invalid data\nexcept KeyError as e:\n    print(f\"Missing required field: {e}\")\n</code></pre>"},{"location":"api/utils/#event-mapping","title":"Event Mapping","text":""},{"location":"api/utils/#event_map","title":"EVENT_MAP","text":"<p>The <code>EVENT_MAP</code> dictionary maps Slack event type strings to their corresponding Pydantic model classes.</p>"},{"location":"api/utils/#slack_models.EVENT_MAP","title":"<code>slack_models.EVENT_MAP = {'message': MessageEvent, 'app_mention': AppMentionEvent, 'reaction_added': ReactionAddedEvent, 'reaction_removed': ReactionRemovedEvent, 'team_join': TeamJoinEvent, 'file_created': FileCreatedEvent, 'file_deleted': FileDeletedEvent, 'channel_created': ChannelCreatedEvent, 'channel_deleted': ChannelDeletedEvent, 'channel_rename': ChannelRenameEvent}</code>  <code>module-attribute</code>","text":""},{"location":"api/utils/#usage-examples_1","title":"Usage Examples","text":""},{"location":"api/utils/#direct-event-type-mapping","title":"Direct Event Type Mapping","text":"<pre><code>from slack_models import EVENT_MAP, MessageEvent\n\n# Get the model class for a specific event type\nevent_type = \"message\"\nmodel_class = EVENT_MAP.get(event_type)\n\nif model_class:\n    print(f\"Event type '{event_type}' maps to {model_class.__name__}\")\n\n# Example: MessageEvent\nassert EVENT_MAP[\"message\"] == MessageEvent\n</code></pre>"},{"location":"api/utils/#dynamic-event-processing","title":"Dynamic Event Processing","text":"<pre><code>from slack_models import EVENT_MAP\n\ndef process_event_data(event_data: dict):\n    \"\"\"Process event data using EVENT_MAP for dynamic model selection.\"\"\"\n    event_type = event_data.get(\"type\")\n\n    if event_type in EVENT_MAP:\n        model_class = EVENT_MAP[event_type]\n        try:\n            event = model_class(**event_data)\n            return event\n        except ValidationError as e:\n            print(f\"Failed to parse {event_type}: {e}\")\n            return None\n    else:\n        print(f\"Unknown event type: {event_type}\")\n        return None\n\n# Usage\nevent_data = {\n    \"type\": \"message\",\n    \"channel\": \"C1234567890\",\n    \"user\": \"U1234567890\",\n    \"text\": \"Hello!\",\n    \"ts\": \"1234567890.123456\"\n}\n\nevent = process_event_data(event_data)\nif event:\n    print(f\"Processed event: {type(event).__name__}\")\n</code></pre>"},{"location":"api/utils/#available-event-types","title":"Available Event Types","text":"<p>The <code>EVENT_MAP</code> contains mappings for the following event types:</p> <pre><code>EVENT_MAP = {\n    \"message\": MessageEvent,\n    \"app_mention\": AppMentionEvent,\n    \"reaction_added\": ReactionAddedEvent,\n    \"reaction_removed\": ReactionRemovedEvent,\n    \"team_join\": TeamJoinEvent,\n    \"file_created\": FileCreatedEvent,\n    \"file_deleted\": FileDeletedEvent,\n    \"channel_created\": ChannelCreatedEvent,\n    \"channel_deleted\": ChannelDeletedEvent,\n    \"channel_rename\": ChannelRenameEvent,\n}\n</code></pre>"},{"location":"api/utils/#utility-patterns","title":"Utility Patterns","text":""},{"location":"api/utils/#custom-event-handler","title":"Custom Event Handler","text":"<pre><code>from slack_models import parse_event, EVENT_MAP, SlackEventCallback\n\nclass EventHandler:\n    def __init__(self):\n        self.handlers = {}\n\n    def register(self, event_type: str, handler_func):\n        \"\"\"Register a handler for a specific event type.\"\"\"\n        self.handlers[event_type] = handler_func\n\n    def handle(self, payload: dict):\n        \"\"\"Handle a webhook payload.\"\"\"\n        event = parse_event(payload)\n\n        if isinstance(event, SlackEventCallback):\n            event_type = event.event.type\n            handler = self.handlers.get(event_type)\n\n            if handler:\n                handler(event.event)\n            else:\n                print(f\"No handler registered for event type: {event_type}\")\n\n# Usage\nhandler = EventHandler()\nhandler.register(\"message\", lambda msg: print(f\"Message: {msg.text}\"))\nhandler.handle(webhook_data)\n</code></pre>"},{"location":"api/utils/#type-safe-event-router","title":"Type-Safe Event Router","text":"<pre><code>from typing import TypeVar, Type, Callable\nfrom slack_models import parse_event, SlackEventCallback, BaseSlackEvent\n\nT = TypeVar('T', bound=BaseSlackEvent)\n\nclass TypedEventRouter:\n    def __init__(self):\n        self.routes = {}\n\n    def route(self, event_class: Type[T]) -&gt; Callable[[Callable[[T], None]], None]:\n        \"\"\"Decorator for registering type-safe event handlers.\"\"\"\n        def decorator(handler_func: Callable[[T], None]):\n            self.routes[event_class] = handler_func\n            return handler_func\n        return decorator\n\n    def handle(self, payload: dict):\n        \"\"\"Handle a webhook payload with type-safe routing.\"\"\"\n        event = parse_event(payload)\n\n        if isinstance(event, SlackEventCallback):\n            handler = self.routes.get(type(event.event))\n            if handler:\n                handler(event.event)\n\n# Usage\nrouter = TypedEventRouter()\n\n@router.route(MessageEvent)\ndef handle_message(message: MessageEvent):\n    print(f\"Message: {message.text}\")\n\n@router.route(ReactionAddedEvent)\ndef handle_reaction(reaction: ReactionAddedEvent):\n    print(f\"Reaction: {reaction.reaction}\")\n\nrouter.handle(webhook_data)\n</code></pre>"},{"location":"api/utils/#error-handling-utilities","title":"Error Handling Utilities","text":""},{"location":"api/utils/#validation-error-helper","title":"Validation Error Helper","text":"<pre><code>from pydantic import ValidationError\nfrom slack_models import parse_event\n\ndef safe_parse_event(payload: dict):\n    \"\"\"Safely parse an event with detailed error reporting.\"\"\"\n    try:\n        return parse_event(payload)\n    except ValidationError as e:\n        print(\"Validation errors:\")\n        for error in e.errors():\n            field = \" -&gt; \".join(str(x) for x in error[\"loc\"])\n            message = error[\"msg\"]\n            print(f\"  {field}: {message}\")\n        return None\n    except Exception as e:\n        print(f\"Unexpected error: {e}\")\n        return None\n\n# Usage\nevent = safe_parse_event(webhook_data)\nif event:\n    print(\"Event parsed successfully\")\n</code></pre>"},{"location":"development/changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"development/changelog/#110-2025-07-10","title":"[1.1.0] - 2025-07-10","text":""},{"location":"development/changelog/#added","title":"Added","text":"<ul> <li>Complete Block Kit support:</li> <li>All block types (Section, Divider, Image, Actions, Context, Input, Header, Video, RichText, File)</li> <li>Interactive elements (Button, Select menus, Input fields, Date pickers, Checkboxes, Radio buttons)</li> <li>Composition objects (TextObject, ConfirmationDialog, Option, OptionGroup)</li> <li>Rich text formatting elements (Section, List, Quote, Preformatted)</li> <li>Union types for type-safe event handling:</li> <li><code>Block</code> union of all block types</li> <li><code>BlockElement</code> union of all block elements   -</li> </ul>"},{"location":"development/changelog/#removed","title":"Removed","text":"<ul> <li>slack_models.ChatMessage</li> </ul>"},{"location":"development/changelog/#100-2025-07-08","title":"[1.0.0] - 2025-07-08","text":""},{"location":"development/changelog/#added_1","title":"Added","text":"<ul> <li>Initial release of slack-models library</li> <li>Comprehensive Pydantic models for Slack API objects</li> <li>Support for all major Slack event types:</li> <li>Message events (including subtypes and threaded messages)</li> <li>Reaction events (added and removed)</li> <li>Channel events (created, deleted, renamed)</li> <li>Team events (member join)</li> <li>File events (created and deleted)</li> <li>App mention events</li> <li>Webhook payload models:</li> <li>Event callbacks</li> <li>URL verification</li> <li>App rate limiting</li> <li>Core Slack object models:</li> <li>User and UserProfile</li> <li>Channel following official Slack API specification</li> <li>File and FileContent</li> <li>EnterpriseUser</li> <li>Authorization</li> <li>ChatMessage</li> <li>Utility functions:</li> <li><code>parse_event()</code> for parsing webhook payloads</li> <li><code>EVENT_MAP</code> for event type mapping</li> <li>Union types for type-safe event handling:</li> <li><code>SlackEvent</code> union of all event types</li> <li><code>SlackWebhookPayload</code> union of all webhook payload types</li> <li>Python 3.12+ support with modern type hints</li> <li>Comprehensive type annotations with <code>py.typed</code> marker</li> <li>Pydantic 2.x compatibility</li> <li>Comprehensive MkDocs documentation with Material theme</li> <li>API reference documentation with mkdocstrings</li> <li>Usage examples for basic operations and event handling</li> <li>Development guide with contributing guidelines and testing documentation</li> </ul>"},{"location":"development/changelog/#technical-details","title":"Technical Details","text":"<ul> <li>Built on Pydantic 2.11.3+ for robust data validation</li> <li>Uses Python 3.10+ union syntax (<code>|</code> operator)</li> <li>Comprehensive docstrings with Slack API references</li> <li>Source layout packaging structure</li> <li>Hatchling build system</li> <li>Pre-commit hooks with ruff formatting and linting</li> <li>MyPy type checking support</li> <li>BSD-3-Clause license</li> </ul>"},{"location":"development/changelog/#development-infrastructure","title":"Development Infrastructure","text":"<ul> <li>GitHub Actions CI/CD pipeline</li> <li>Automated testing with pytest (140 tests with 99% coverage)</li> <li>Code coverage reporting</li> <li>Documentation generation with MkDocs</li> <li>Pre-commit hooks for code quality</li> <li>Ruff linting and formatting</li> <li>MyPy static type checking</li> </ul>"},{"location":"development/changelog/#api-compliance","title":"API Compliance","text":"<ul> <li>Strict adherence to official Slack API specifications</li> <li>All models match official Slack object structures</li> <li>Comprehensive validation and type safety</li> <li>EVENT_MAP dictionary for efficient event type resolution</li> </ul>"},{"location":"development/changelog/#documentation","title":"Documentation","text":"<ul> <li>Comprehensive API documentation</li> <li>Usage examples and best practices</li> <li>Development and contribution guidelines</li> <li>Testing documentation and examples</li> </ul>"},{"location":"development/changelog/#development-history","title":"Development History","text":"<p>The slack-models library was developed internally at AWeber to support Slack bot projects. Key development milestones included:</p> <ul> <li>Initial Design: Core model architecture based on Slack API documentation</li> <li>Pydantic Integration: Implementation using Pydantic 2.x for enhanced validation</li> <li>Type Safety: Implementation of comprehensive type annotations</li> <li>Testing Framework: Development of extensive test coverage</li> <li>Documentation: Creation of comprehensive documentation system</li> <li>CI/CD Pipeline: Implementation of automated testing and deployment</li> </ul>"},{"location":"development/changelog/#future-compatibility","title":"Future Compatibility","text":"<ul> <li>The library follows semantic versioning</li> <li>Minor version updates will add new features without breaking changes</li> <li>Major version updates may include breaking changes with migration guides</li> <li>Deprecated features will be marked and supported for at least one major version</li> </ul>"},{"location":"development/changelog/#acknowledgments","title":"Acknowledgments","text":"<p>This library was developed to support Slack bot projects at AWeber. Special thanks to:</p> <ul> <li>The Slack API team for comprehensive documentation</li> <li>The Pydantic team for the excellent validation framework</li> <li>The Python community for typing and tooling improvements</li> </ul>"},{"location":"development/changelog/#support","title":"Support","text":"<p>For questions, issues, or contributions: - GitHub Issues: https://github.com/gmr/slack-models/issues - Documentation: https://gmr.github.io/slack-models/ - Source Code: https://github.com/gmr/slack-models</p>"},{"location":"development/contributing/","title":"Contributing to slack-models","text":"<p>Thank you for your interest in contributing to slack-models! This guide will help you get started with contributing to the project.</p>"},{"location":"development/contributing/#getting-started","title":"Getting Started","text":""},{"location":"development/contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12 or higher</li> <li>Git</li> <li>Basic understanding of Pydantic models</li> <li>Familiarity with the Slack API</li> </ul>"},{"location":"development/contributing/#development-setup","title":"Development Setup","text":"<ol> <li>Fork and Clone the Repository</li> </ol> <pre><code>git clone https://github.com/yourusername/slack-models.git\ncd slack-models\n</code></pre> <ol> <li>Create a Virtual Environment</li> </ol> <pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n</code></pre> <ol> <li>Install Development Dependencies</li> </ol> <pre><code>pip install -e '.[dev]'\n</code></pre> <ol> <li>Install Pre-commit Hooks</li> </ol> <pre><code>pre-commit install\n</code></pre> <ol> <li>Verify Installation</li> </ol> <pre><code># Run tests\npytest\n\n# Run linting\nruff check .\n\n# Run type checking\nmypy src/slack_models\n\n# Build documentation\nmkdocs build\n</code></pre>"},{"location":"development/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"development/contributing/#code-style","title":"Code Style","text":"<p>The project follows strict code style guidelines:</p> <ul> <li>Line Length: 79 characters maximum</li> <li>Quotes: Single quotes for strings</li> <li>Type Annotations: Required for all functions and methods</li> <li>Python Version: Python 3.12+ features are encouraged</li> </ul>"},{"location":"development/contributing/#linting-and-formatting","title":"Linting and Formatting","text":"<p>We use <code>ruff</code> for both linting and formatting:</p> <pre><code># Format code\nruff format .\n\n# Check for linting issues\nruff check .\n\n# Fix auto-fixable issues\nruff check --fix .\n</code></pre>"},{"location":"development/contributing/#type-checking","title":"Type Checking","text":"<p>All code must pass mypy type checking:</p> <pre><code>mypy src/slack_models\n</code></pre>"},{"location":"development/contributing/#testing","title":"Testing","text":"<p>Tests are written using pytest and should achieve high coverage:</p> <pre><code># Run all tests\npytest\n\n# Run with coverage\npytest --cov=slack_models --cov-report=html\n\n# Run specific test file\npytest tests/test_models.py\n</code></pre>"},{"location":"development/contributing/#contributing-guidelines","title":"Contributing Guidelines","text":""},{"location":"development/contributing/#bug-reports","title":"Bug Reports","text":"<p>When reporting bugs, please include:</p> <ol> <li>Python Version: Output of <code>python --version</code></li> <li>slack-models Version: Output of <code>python -c \"import slack_models; print(slack_models.version)\"</code></li> <li>Error Details: Complete error message and traceback</li> <li>Reproduction Steps: Minimal code example that reproduces the issue</li> <li>Expected Behavior: What you expected to happen</li> <li>Actual Behavior: What actually happened</li> </ol>"},{"location":"development/contributing/#feature-requests","title":"Feature Requests","text":"<p>For new features, please:</p> <ol> <li>Check Existing Issues: Ensure the feature hasn't been requested</li> <li>Provide Use Case: Explain why this feature would be valuable</li> <li>Propose Implementation: If possible, suggest how it might be implemented</li> <li>Consider Backwards Compatibility: Ensure it doesn't break existing code</li> </ol>"},{"location":"development/contributing/#pull-requests","title":"Pull Requests","text":""},{"location":"development/contributing/#before-submitting","title":"Before Submitting","text":"<ol> <li>Create an Issue: For significant changes, create an issue first</li> <li>Fork the Repository: Work on your own fork</li> <li>Create a Feature Branch: Use descriptive branch names</li> <li>Write Tests: Ensure your changes are well-tested</li> <li>Update Documentation: Add or update relevant documentation</li> <li>Check Style: Ensure code follows project style guidelines</li> </ol>"},{"location":"development/contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Commit Messages: Write clear, descriptive commit messages</li> <li>Small Commits: Make small, focused commits</li> <li>Test Coverage: Maintain or improve test coverage</li> <li>Documentation: Update documentation as needed</li> <li>Changelog: Add entry to changelog if applicable</li> </ol>"},{"location":"development/contributing/#example-pull-request","title":"Example Pull Request","text":"<pre><code># Create feature branch\ngit checkout -b feature/add-new-event-type\n\n# Make your changes\n# ... edit files ...\n\n# Add tests\n# ... add test files ...\n\n# Update documentation\n# ... update docs ...\n\n# Commit changes\ngit add .\ngit commit -m \"Add support for new_event_type\n\n- Add NewEventType model to _models.py\n- Update EVENT_MAP with new event type\n- Add comprehensive tests for new event type\n- Update documentation with usage examples\"\n\n# Push branch\ngit push origin feature/add-new-event-type\n\n# Create pull request on GitHub\n</code></pre>"},{"location":"development/contributing/#code-organization","title":"Code Organization","text":""},{"location":"development/contributing/#project-structure","title":"Project Structure","text":"<pre><code>slack-models/\n\u251c\u2500\u2500 src/slack_models/          # Main package\n\u2502   \u251c\u2500\u2500 __init__.py           # Package exports\n\u2502   \u251c\u2500\u2500 _models.py            # Pydantic models\n\u2502   \u251c\u2500\u2500 _utils.py             # Utility functions\n\u2502   \u2514\u2500\u2500 py.typed              # Type annotations marker\n\u251c\u2500\u2500 tests/                    # Test files\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 test_models.py        # Model tests\n\u2502   \u251c\u2500\u2500 test_utils.py         # Utility tests\n\u2502   \u2514\u2500\u2500 test_data.py          # Test data\n\u251c\u2500\u2500 docs/                     # Documentation\n\u2502   \u251c\u2500\u2500 api/                  # API documentation\n\u2502   \u251c\u2500\u2500 examples/             # Usage examples\n\u2502   \u2514\u2500\u2500 development/          # Development guides\n\u251c\u2500\u2500 pyproject.toml            # Project configuration\n\u251c\u2500\u2500 mkdocs.yml               # Documentation config\n\u2514\u2500\u2500 CLAUDE.md                # AI assistant guide\n</code></pre>"},{"location":"development/contributing/#adding-new-models","title":"Adding New Models","text":"<p>When adding new Slack event or object models:</p> <ol> <li>Add to <code>_models.py</code>: Define the Pydantic model</li> <li>Update <code>__init__.py</code>: Add to exports</li> <li>Update <code>EVENT_MAP</code>: If it's an event type</li> <li>Add Tests: Comprehensive test coverage</li> <li>Update Documentation: Add to API docs and examples</li> </ol>"},{"location":"development/contributing/#example-adding-a-new-event-type","title":"Example: Adding a New Event Type","text":"<pre><code># In _models.py\nclass NewEventType(BaseSlackEvent):\n    \"\"\"Documentation for the new event type.\n\n    Include purpose, required OAuth scopes, and key characteristics.\n    \"\"\"\n\n    type: typing.Literal[\"new_event_type\"]\n    user: str\n    timestamp: str\n    # ... other fields\n\n# In EVENT_MAP\nEVENT_MAP = {\n    # ... existing events\n    \"new_event_type\": NewEventType,\n}\n\n# In __init__.py\n__all__ = [\n    # ... existing exports\n    \"NewEventType\",\n]\n</code></pre>"},{"location":"development/contributing/#documentation-guidelines","title":"Documentation Guidelines","text":""},{"location":"development/contributing/#docstrings","title":"Docstrings","text":"<p>All models and functions must have comprehensive docstrings:</p> <pre><code>class ExampleModel(pydantic.BaseModel):\n    \"\"\"Brief description of the model.\n\n    Longer description including:\n    - Purpose and use cases\n    - Required OAuth scopes (if applicable)\n    - Key characteristics\n    - Relationship to other models\n\n    Example:\n        ```python\n        model = ExampleModel(\n            field1=\"value1\",\n            field2=\"value2\"\n        )\n        ```\n    \"\"\"\n\n    field1: str\n    field2: str | None = None\n</code></pre>"},{"location":"development/contributing/#api-documentation","title":"API Documentation","text":"<ul> <li>Use mkdocstrings for auto-generated API docs</li> <li>Include usage examples in docstrings</li> <li>Link to official Slack API documentation</li> <li>Provide type annotations for all parameters</li> </ul>"},{"location":"development/contributing/#examples","title":"Examples","text":"<ul> <li>Create practical, real-world examples</li> <li>Include error handling</li> <li>Show best practices</li> <li>Cover common use cases</li> </ul>"},{"location":"development/contributing/#testing-guidelines","title":"Testing Guidelines","text":""},{"location":"development/contributing/#test-structure","title":"Test Structure","text":"<pre><code>import pytest\nfrom slack_models import ModelName\n\nclass TestModelName:\n    \"\"\"Test cases for ModelName.\"\"\"\n\n    def test_basic_creation(self):\n        \"\"\"Test basic model creation.\"\"\"\n        model = ModelName(field1=\"value1\")\n        assert model.field1 == \"value1\"\n\n    def test_validation_error(self):\n        \"\"\"Test validation error handling.\"\"\"\n        with pytest.raises(ValidationError):\n            ModelName(invalid_field=\"invalid\")\n\n    def test_optional_fields(self):\n        \"\"\"Test optional field handling.\"\"\"\n        model = ModelName(field1=\"value1\")\n        assert model.field2 is None\n</code></pre>"},{"location":"development/contributing/#test-data","title":"Test Data","text":"<p>Create reusable test data:</p> <pre><code># tests/test_data.py\nSAMPLE_MESSAGE_EVENT = {\n    \"type\": \"message\",\n    \"channel\": \"C1234567890\",\n    \"user\": \"U1234567890\",\n    \"text\": \"Hello, world!\",\n    \"ts\": \"1234567890.123456\"\n}\n\nSAMPLE_WEBHOOK_PAYLOAD = {\n    \"type\": \"event_callback\",\n    \"event\": SAMPLE_MESSAGE_EVENT,\n    \"team_id\": \"T1234567890\",\n    \"api_app_id\": \"A1234567890\"\n}\n</code></pre>"},{"location":"development/contributing/#coverage-requirements","title":"Coverage Requirements","text":"<ul> <li>Maintain minimum 90% test coverage</li> <li>Test all validation branches</li> <li>Test error conditions</li> <li>Test edge cases and boundary conditions</li> </ul>"},{"location":"development/contributing/#release-process","title":"Release Process","text":""},{"location":"development/contributing/#version-management","title":"Version Management","text":"<ul> <li>Version is stored in <code>pyproject.toml</code></li> <li>Follow semantic versioning (MAJOR.MINOR.PATCH)</li> <li>Update version for releases</li> </ul>"},{"location":"development/contributing/#changelog","title":"Changelog","text":"<p>Maintain a changelog in <code>docs/development/changelog.md</code>:</p> <pre><code>## [1.1.0] - 2024-01-15\n\n### Added\n- New event type support\n- Additional utility functions\n\n### Changed\n- Updated documentation structure\n\n### Fixed\n- Validation error in Channel model\n\n### Deprecated\n- Old utility function (will be removed in 2.0.0)\n</code></pre>"},{"location":"development/contributing/#release-checklist","title":"Release Checklist","text":"<ol> <li>Update Version: Increment version in <code>pyproject.toml</code></li> <li>Update Changelog: Add release notes</li> <li>Run Tests: Ensure all tests pass</li> <li>Build Documentation: Update and build docs</li> <li>Create Release: Tag and create GitHub release</li> <li>Publish Package: Upload to PyPI</li> </ol>"},{"location":"development/contributing/#getting-help","title":"Getting Help","text":""},{"location":"development/contributing/#community-resources","title":"Community Resources","text":"<ul> <li>GitHub Issues: For bug reports and feature requests</li> <li>GitHub Discussions: For questions and general discussion</li> <li>Documentation: Comprehensive guides and examples</li> </ul>"},{"location":"development/contributing/#communication-guidelines","title":"Communication Guidelines","text":"<ul> <li>Be respectful and constructive</li> <li>Provide detailed information</li> <li>Search existing issues before creating new ones</li> <li>Follow up on your contributions</li> </ul>"},{"location":"development/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>We follow the Contributor Covenant Code of Conduct. Please read and follow it in all interactions.</p>"},{"location":"development/contributing/#recognition","title":"Recognition","text":"<p>Contributors will be recognized in:</p> <ul> <li>GitHub contributors list</li> <li>Release notes</li> <li>Documentation credits</li> </ul> <p>Thank you for contributing to slack-models! Your contributions help make Slack API integration easier for everyone.</p>"},{"location":"development/testing/","title":"Testing Guide","text":"<p>This guide covers testing practices and guidelines for the slack-models library.</p>"},{"location":"development/testing/#test-structure","title":"Test Structure","text":""},{"location":"development/testing/#test-organization","title":"Test Organization","text":"<p>Tests are organized in the <code>tests/</code> directory:</p> <pre><code>tests/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 test_models.py      # Model validation tests\n\u251c\u2500\u2500 test_utils.py       # Utility function tests\n\u251c\u2500\u2500 test_events.py      # Event parsing tests\n\u2514\u2500\u2500 test_data.py        # Test data fixtures\n</code></pre>"},{"location":"development/testing/#test-framework","title":"Test Framework","text":"<p>We use pytest for testing with the following key features:</p> <ul> <li>Fixtures: Reusable test data</li> <li>Parametrized Tests: Multiple test cases from single test function</li> <li>Coverage: Test coverage reporting</li> <li>Assertions: Rich assertion information</li> </ul>"},{"location":"development/testing/#running-tests","title":"Running Tests","text":""},{"location":"development/testing/#basic-test-execution","title":"Basic Test Execution","text":"<pre><code># Run all tests\npytest\n\n# Run specific test file\npytest tests/test_models.py\n\n# Run specific test class\npytest tests/test_models.py::TestMessageEvent\n\n# Run specific test method\npytest tests/test_models.py::TestMessageEvent::test_basic_creation\n</code></pre>"},{"location":"development/testing/#test-with-coverage","title":"Test with Coverage","text":"<pre><code># Run tests with coverage\npytest --cov=slack_models\n\n# Generate HTML coverage report\npytest --cov=slack_models --cov-report=html\n\n# Generate XML coverage report (for CI)\npytest --cov=slack_models --cov-report=xml\n</code></pre>"},{"location":"development/testing/#verbose-output","title":"Verbose Output","text":"<pre><code># Run with verbose output\npytest -v\n\n# Run with even more verbose output\npytest -vv\n\n# Show print statements\npytest -s\n</code></pre>"},{"location":"development/testing/#writing-tests","title":"Writing Tests","text":""},{"location":"development/testing/#basic-test-structure","title":"Basic Test Structure","text":"<pre><code>import pytest\nfrom pydantic import ValidationError\nfrom slack_models import MessageEvent, parse_event\n\nclass TestMessageEvent:\n    \"\"\"Test cases for MessageEvent model.\"\"\"\n\n    def test_basic_creation(self):\n        \"\"\"Test basic message event creation.\"\"\"\n        event_data = {\n            \"type\": \"message\",\n            \"channel\": \"C1234567890\",\n            \"user\": \"U1234567890\",\n            \"text\": \"Hello, world!\",\n            \"ts\": \"1234567890.123456\"\n        }\n\n        event = MessageEvent(**event_data)\n\n        assert event.type == \"message\"\n        assert event.channel == \"C1234567890\"\n        assert event.user == \"U1234567890\"\n        assert event.text == \"Hello, world!\"\n        assert event.ts == \"1234567890.123456\"\n\n    def test_optional_fields(self):\n        \"\"\"Test optional field handling.\"\"\"\n        event_data = {\n            \"type\": \"message\",\n            \"channel\": \"C1234567890\",\n            \"user\": \"U1234567890\",\n            \"text\": \"Hello, world!\",\n            \"ts\": \"1234567890.123456\"\n        }\n\n        event = MessageEvent(**event_data)\n\n        # Test optional fields have default values\n        assert event.subtype is None\n        assert event.thread_ts is None\n        assert event.edited is None\n        assert event.reactions is None\n\n    def test_validation_error(self):\n        \"\"\"Test validation error for missing required fields.\"\"\"\n        event_data = {\n            \"type\": \"message\",\n            # Missing required fields\n        }\n\n        with pytest.raises(ValidationError) as exc_info:\n            MessageEvent(**event_data)\n\n        # Check specific validation errors\n        errors = exc_info.value.errors()\n        error_fields = [error[\"loc\"][0] for error in errors]\n\n        assert \"channel\" in error_fields\n        assert \"user\" in error_fields\n        assert \"ts\" in error_fields\n</code></pre>"},{"location":"development/testing/#fixtures","title":"Fixtures","text":"<p>Create reusable test data using fixtures:</p> <pre><code># tests/conftest.py\nimport pytest\n\n@pytest.fixture\ndef sample_message_event():\n    \"\"\"Sample message event data.\"\"\"\n    return {\n        \"type\": \"message\",\n        \"channel\": \"C1234567890\",\n        \"user\": \"U1234567890\",\n        \"text\": \"Hello, world!\",\n        \"ts\": \"1234567890.123456\"\n    }\n\n@pytest.fixture\ndef sample_webhook_payload():\n    \"\"\"Sample webhook payload data.\"\"\"\n    return {\n        \"type\": \"event_callback\",\n        \"event\": {\n            \"type\": \"message\",\n            \"channel\": \"C1234567890\",\n            \"user\": \"U1234567890\",\n            \"text\": \"Hello, world!\",\n            \"ts\": \"1234567890.123456\"\n        },\n        \"team_id\": \"T1234567890\",\n        \"api_app_id\": \"A1234567890\"\n    }\n\n# Usage in tests\ndef test_message_event_creation(sample_message_event):\n    \"\"\"Test message event creation using fixture.\"\"\"\n    event = MessageEvent(**sample_message_event)\n    assert event.text == \"Hello, world!\"\n</code></pre>"},{"location":"development/testing/#parametrized-tests","title":"Parametrized Tests","text":"<p>Test multiple scenarios with parametrized tests:</p> <pre><code>@pytest.mark.parametrize(\"event_type,expected_class\", [\n    (\"message\", MessageEvent),\n    (\"app_mention\", AppMentionEvent),\n    (\"reaction_added\", ReactionAddedEvent),\n    (\"reaction_removed\", ReactionRemovedEvent),\n    (\"team_join\", TeamJoinEvent),\n])\ndef test_event_type_mapping(event_type, expected_class):\n    \"\"\"Test event type to class mapping.\"\"\"\n    from slack_models import EVENT_MAP\n\n    assert EVENT_MAP[event_type] == expected_class\n\n@pytest.mark.parametrize(\"invalid_data,expected_error\", [\n    ({}, \"channel\"),  # Missing channel\n    ({\"channel\": \"C123\"}, \"user\"),  # Missing user\n    ({\"channel\": \"C123\", \"user\": \"U123\"}, \"ts\"),  # Missing ts\n])\ndef test_validation_errors(invalid_data, expected_error):\n    \"\"\"Test various validation errors.\"\"\"\n    invalid_data[\"type\"] = \"message\"\n\n    with pytest.raises(ValidationError) as exc_info:\n        MessageEvent(**invalid_data)\n\n    error_fields = [error[\"loc\"][0] for error in exc_info.value.errors()]\n    assert expected_error in error_fields\n</code></pre>"},{"location":"development/testing/#mock-testing","title":"Mock Testing","text":"<p>Use mocks for external dependencies:</p> <pre><code>from unittest.mock import Mock, patch\nimport pytest\n\ndef test_event_processing_with_mock():\n    \"\"\"Test event processing with mocked dependencies.\"\"\"\n    # Mock external service\n    with patch('slack_models.some_external_service') as mock_service:\n        mock_service.return_value = {\"status\": \"success\"}\n\n        # Test code that uses the external service\n        result = process_event(sample_event)\n\n        assert result[\"status\"] == \"success\"\n        mock_service.assert_called_once()\n</code></pre>"},{"location":"development/testing/#test-data-management","title":"Test Data Management","text":""},{"location":"development/testing/#creating-test-data","title":"Creating Test Data","text":"<pre><code># tests/test_data.py\n\"\"\"Test data fixtures for slack-models tests.\"\"\"\n\n# Message Events\nSAMPLE_MESSAGE_EVENT = {\n    \"type\": \"message\",\n    \"channel\": \"C1234567890\",\n    \"user\": \"U1234567890\",\n    \"text\": \"Hello, world!\",\n    \"ts\": \"1234567890.123456\"\n}\n\nSAMPLE_BOT_MESSAGE_EVENT = {\n    \"type\": \"message\",\n    \"subtype\": \"bot_message\",\n    \"channel\": \"C1234567890\",\n    \"bot_id\": \"B1234567890\",\n    \"username\": \"testbot\",\n    \"text\": \"Bot message\",\n    \"ts\": \"1234567890.123456\"\n}\n\nSAMPLE_THREADED_MESSAGE_EVENT = {\n    \"type\": \"message\",\n    \"channel\": \"C1234567890\",\n    \"user\": \"U1234567890\",\n    \"text\": \"Reply in thread\",\n    \"ts\": \"1234567890.123456\",\n    \"thread_ts\": \"1234567890.123456\"\n}\n\n# Reaction Events\nSAMPLE_REACTION_ADDED_EVENT = {\n    \"type\": \"reaction_added\",\n    \"user\": \"U1234567890\",\n    \"reaction\": \"thumbsup\",\n    \"item\": {\n        \"type\": \"message\",\n        \"channel\": \"C1234567890\",\n        \"ts\": \"1234567890.123456\"\n    },\n    \"item_user\": \"U0987654321\",\n    \"event_ts\": \"1234567890.654321\"\n}\n\n# Webhook Payloads\nSAMPLE_EVENT_CALLBACK = {\n    \"type\": \"event_callback\",\n    \"event\": SAMPLE_MESSAGE_EVENT,\n    \"team_id\": \"T1234567890\",\n    \"api_app_id\": \"A1234567890\"\n}\n\nSAMPLE_URL_VERIFICATION = {\n    \"type\": \"url_verification\",\n    \"challenge\": \"3eZbrw1aBm2rZgRNFdxV2595E9CY3gmdALWMmHkvFXO7tYXAYM8P\"\n}\n\n# User and Channel Data\nSAMPLE_USER = {\n    \"id\": \"U1234567890\",\n    \"name\": \"john.doe\",\n    \"real_name\": \"John Doe\",\n    \"profile\": {\n        \"email\": \"john.doe@example.com\",\n        \"display_name\": \"John\",\n        \"first_name\": \"John\",\n        \"last_name\": \"Doe\"\n    }\n}\n\nSAMPLE_CHANNEL = {\n    \"id\": \"C1234567890\",\n    \"name\": \"general\",\n    \"created\": 1234567890,\n    \"creator\": \"U1234567890\",\n    \"is_channel\": True,\n    \"is_general\": True,\n    \"is_member\": True\n}\n</code></pre>"},{"location":"development/testing/#data-factories","title":"Data Factories","text":"<p>Create data factories for generating test data:</p> <pre><code># tests/factories.py\n\"\"\"Data factories for generating test data.\"\"\"\n\nfrom typing import Dict, Any\nimport time\n\nclass EventFactory:\n    \"\"\"Factory for creating event data.\"\"\"\n\n    @staticmethod\n    def message_event(**kwargs) -&gt; Dict[str, Any]:\n        \"\"\"Create message event data.\"\"\"\n        base_data = {\n            \"type\": \"message\",\n            \"channel\": \"C1234567890\",\n            \"user\": \"U1234567890\",\n            \"text\": \"Test message\",\n            \"ts\": str(time.time())\n        }\n        base_data.update(kwargs)\n        return base_data\n\n    @staticmethod\n    def reaction_event(**kwargs) -&gt; Dict[str, Any]:\n        \"\"\"Create reaction event data.\"\"\"\n        base_data = {\n            \"type\": \"reaction_added\",\n            \"user\": \"U1234567890\",\n            \"reaction\": \"thumbsup\",\n            \"item\": {\n                \"type\": \"message\",\n                \"channel\": \"C1234567890\",\n                \"ts\": str(time.time())\n            },\n            \"item_user\": \"U0987654321\",\n            \"event_ts\": str(time.time())\n        }\n        base_data.update(kwargs)\n        return base_data\n\n    @staticmethod\n    def webhook_payload(event_data: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Create webhook payload data.\"\"\"\n        return {\n            \"type\": \"event_callback\",\n            \"event\": event_data,\n            \"team_id\": \"T1234567890\",\n            \"api_app_id\": \"A1234567890\"\n        }\n\n# Usage in tests\ndef test_with_factory():\n    \"\"\"Test using data factory.\"\"\"\n    event_data = EventFactory.message_event(text=\"Custom message\")\n    event = MessageEvent(**event_data)\n    assert event.text == \"Custom message\"\n</code></pre>"},{"location":"development/testing/#testing-strategies","title":"Testing Strategies","text":""},{"location":"development/testing/#model-validation-testing","title":"Model Validation Testing","text":"<pre><code>def test_model_validation_comprehensive():\n    \"\"\"Comprehensive model validation testing.\"\"\"\n\n    # Test required fields\n    with pytest.raises(ValidationError):\n        MessageEvent()\n\n    # Test field types\n    with pytest.raises(ValidationError):\n        MessageEvent(\n            type=\"message\",\n            channel=123,  # Should be string\n            user=\"U123\",\n            text=\"Test\",\n            ts=\"123\"\n        )\n\n    # Test field constraints\n    with pytest.raises(ValidationError):\n        MessageEvent(\n            type=\"invalid_type\",  # Should be \"message\"\n            channel=\"C123\",\n            user=\"U123\",\n            text=\"Test\",\n            ts=\"123\"\n        )\n\n    # Test optional fields\n    event = MessageEvent(\n        type=\"message\",\n        channel=\"C123\",\n        user=\"U123\",\n        text=\"Test\",\n        ts=\"123\"\n    )\n\n    assert event.subtype is None\n    assert event.thread_ts is None\n</code></pre>"},{"location":"development/testing/#integration-testing","title":"Integration Testing","text":"<pre><code>def test_full_webhook_processing():\n    \"\"\"Test complete webhook processing pipeline.\"\"\"\n    webhook_payload = {\n        \"type\": \"event_callback\",\n        \"event\": {\n            \"type\": \"message\",\n            \"channel\": \"C1234567890\",\n            \"user\": \"U1234567890\",\n            \"text\": \"Hello, world!\",\n            \"ts\": \"1234567890.123456\"\n        },\n        \"team_id\": \"T1234567890\",\n        \"api_app_id\": \"A1234567890\"\n    }\n\n    # Parse event\n    event = parse_event(webhook_payload)\n\n    # Verify event structure\n    assert isinstance(event, SlackEventCallback)\n    assert isinstance(event.event, MessageEvent)\n    assert event.team_id == \"T1234567890\"\n    assert event.api_app_id == \"A1234567890\"\n\n    # Verify message content\n    message = event.event\n    assert message.text == \"Hello, world!\"\n    assert message.channel == \"C1234567890\"\n    assert message.user == \"U1234567890\"\n</code></pre>"},{"location":"development/testing/#error-handling-testing","title":"Error Handling Testing","text":"<pre><code>def test_error_handling():\n    \"\"\"Test error handling in various scenarios.\"\"\"\n\n    # Test malformed JSON\n    with pytest.raises(ValidationError):\n        parse_event({\"invalid\": \"data\"})\n\n    # Test missing required fields\n    with pytest.raises(ValidationError):\n        parse_event({\n            \"type\": \"event_callback\",\n            \"event\": {\n                \"type\": \"message\"\n                # Missing required fields\n            }\n        })\n\n    # Test invalid event type\n    with pytest.raises(ValidationError):\n        parse_event({\n            \"type\": \"event_callback\",\n            \"event\": {\n                \"type\": \"unknown_event_type\"\n            }\n        })\n</code></pre>"},{"location":"development/testing/#coverage-guidelines","title":"Coverage Guidelines","text":""},{"location":"development/testing/#coverage-requirements","title":"Coverage Requirements","text":"<ul> <li>Minimum Coverage: 90% overall</li> <li>Statement Coverage: All statements should be executed</li> <li>Branch Coverage: All conditional branches should be tested</li> <li>Function Coverage: All functions should be called</li> </ul>"},{"location":"development/testing/#checking-coverage","title":"Checking Coverage","text":"<pre><code># Run tests with coverage\npytest --cov=slack_models --cov-report=html\n\n# View coverage report\nopen htmlcov/index.html\n\n# Show missing lines\npytest --cov=slack_models --cov-report=term-missing\n</code></pre>"},{"location":"development/testing/#coverage-configuration","title":"Coverage Configuration","text":"<pre><code># pyproject.toml\n[tool.coverage.run]\nsource = [\"src\"]\nomit = [\n    \"tests/*\",\n    \"*/test_*\",\n]\n\n[tool.coverage.report]\nexclude_lines = [\n    \"pragma: no cover\",\n    \"def __repr__\",\n    \"raise AssertionError\",\n    \"raise NotImplementedError\",\n]\n</code></pre>"},{"location":"development/testing/#continuous-integration","title":"Continuous Integration","text":""},{"location":"development/testing/#github-actions","title":"GitHub Actions","text":"<pre><code># .github/workflows/test.yml\nname: Test\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [\"3.12\", \"3.13\"]\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v5\n      with:\n        python-version: ${{ matrix.python-version }}\n\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install -e '.[dev]'\n\n    - name: Run tests\n      run: |\n        pytest --cov=slack_models --cov-report=xml\n\n    - name: Upload coverage\n      uses: codecov/codecov-action@v4\n      with:\n        file: ./coverage.xml\n</code></pre>"},{"location":"development/testing/#test-commands","title":"Test Commands","text":"<pre><code># Run all quality checks\nmake test\n\n# Or manually:\nruff check .\nruff format .\nmypy src/slack_models\npytest --cov=slack_models --cov-report=xml\n</code></pre>"},{"location":"development/testing/#best-practices","title":"Best Practices","text":""},{"location":"development/testing/#test-organization_1","title":"Test Organization","text":"<ol> <li>One Test Class per Model: Keep tests organized by model</li> <li>Descriptive Test Names: Use clear, descriptive test method names</li> <li>Arrange-Act-Assert: Follow AAA pattern in test structure</li> <li>Independent Tests: Each test should be independent and isolated</li> </ol>"},{"location":"development/testing/#test-data","title":"Test Data","text":"<ol> <li>Use Fixtures: Create reusable test data with fixtures</li> <li>Realistic Data: Use realistic Slack API data structures</li> <li>Edge Cases: Test boundary conditions and edge cases</li> <li>Error Scenarios: Test error conditions and validation failures</li> </ol>"},{"location":"development/testing/#assertions","title":"Assertions","text":"<ol> <li>Specific Assertions: Use specific assertions for better error messages</li> <li>Multiple Assertions: It's okay to have multiple assertions per test</li> <li>Expected Exceptions: Use pytest.raises for expected exceptions</li> <li>Custom Assertions: Create custom assertion helpers for complex validations</li> </ol>"},{"location":"development/testing/#performance","title":"Performance","text":"<ol> <li>Fast Tests: Keep tests fast and efficient</li> <li>Minimal Setup: Only set up what's needed for each test</li> <li>Parallel Execution: Use pytest-xdist for parallel test execution</li> <li>Test Isolation: Ensure tests don't interfere with each other</li> </ol> <p>By following these testing guidelines, you'll help maintain the quality and reliability of the slack-models library.</p>"},{"location":"examples/basic/","title":"Basic Usage Examples","text":"<p>This guide provides practical examples of using slack-models in common scenarios.</p>"},{"location":"examples/basic/#simple-event-parsing","title":"Simple Event Parsing","text":""},{"location":"examples/basic/#basic-message-event","title":"Basic Message Event","text":"<pre><code>from slack_models import parse_event, SlackEventCallback, MessageEvent\n\n# Example webhook payload from Slack\nwebhook_payload = {\n    \"type\": \"event_callback\",\n    \"event\": {\n        \"type\": \"message\",\n        \"channel\": \"C1234567890\",\n        \"user\": \"U1234567890\",\n        \"text\": \"Hello, world!\",\n        \"ts\": \"1234567890.123456\"\n    },\n    \"team_id\": \"T1234567890\",\n    \"api_app_id\": \"A1234567890\"\n}\n\n# Parse the event\nevent = parse_event(webhook_payload)\n\n# Type-safe handling\nif isinstance(event, SlackEventCallback):\n    if isinstance(event.event, MessageEvent):\n        message = event.event\n        print(f\"Message: {message.text}\")\n        print(f\"Channel: {message.channel}\")\n        print(f\"User: {message.user}\")\n        print(f\"Timestamp: {message.ts}\")\n</code></pre>"},{"location":"examples/basic/#url-verification","title":"URL Verification","text":"<pre><code>from slack_models import parse_event, SlackUrlVerification\n\n# URL verification challenge from Slack\nverification_payload = {\n    \"type\": \"url_verification\",\n    \"challenge\": \"3eZbrw1aBm2rZgRNFdxV2595E9CY3gmdALWMmHkvFXO7tYXAYM8P\"\n}\n\nevent = parse_event(verification_payload)\n\nif isinstance(event, SlackUrlVerification):\n    # Return the challenge for verification\n    challenge_response = event.challenge\n    print(f\"Challenge: {challenge_response}\")\n</code></pre>"},{"location":"examples/basic/#working-with-core-models","title":"Working with Core Models","text":""},{"location":"examples/basic/#user-information","title":"User Information","text":"<pre><code>from slack_models import User, UserProfile\n\n# Create a user with profile information\nuser_data = {\n    \"id\": \"U1234567890\",\n    \"name\": \"john.doe\",\n    \"real_name\": \"John Doe\",\n    \"profile\": {\n        \"email\": \"john.doe@example.com\",\n        \"display_name\": \"John\",\n        \"first_name\": \"John\",\n        \"last_name\": \"Doe\",\n        \"title\": \"Software Engineer\",\n        \"phone\": \"+1-555-123-4567\",\n        \"status_text\": \"Working remotely\",\n        \"status_emoji\": \":house_with_garden:\",\n        \"image_72\": \"https://avatars.slack-edge.com/2023-01-01/72x72.jpg\"\n    },\n    \"is_admin\": False,\n    \"is_owner\": False,\n    \"is_bot\": False,\n    \"updated\": 1234567890\n}\n\nuser = User(**user_data)\n\n# Access user information\nprint(f\"User: {user.name} ({user.real_name})\")\nprint(f\"Email: {user.profile.email}\")\nprint(f\"Title: {user.profile.title}\")\nprint(f\"Status: {user.profile.status_text} {user.profile.status_emoji}\")\nprint(f\"Is admin: {user.is_admin}\")\n</code></pre>"},{"location":"examples/basic/#channel-information","title":"Channel Information","text":"<pre><code>from slack_models import Channel\n\n# Create a channel object\nchannel_data = {\n    \"id\": \"C1234567890\",\n    \"name\": \"general\",\n    \"created\": 1234567890,\n    \"creator\": \"U1234567890\",\n    \"is_channel\": True,\n    \"is_general\": True,\n    \"is_member\": True,\n    \"is_archived\": False,\n    \"topic\": {\n        \"value\": \"General discussion\",\n        \"creator\": \"U1234567890\",\n        \"last_set\": 1234567890\n    },\n    \"purpose\": {\n        \"value\": \"Company-wide announcements and general chat\",\n        \"creator\": \"U1234567890\",\n        \"last_set\": 1234567890\n    },\n    \"members\": [\"U1234567890\", \"U0987654321\"],\n    \"unread_count\": 5,\n    \"unread_count_display\": 5\n}\n\nchannel = Channel(**channel_data)\n\n# Access channel information\nprint(f\"Channel: #{channel.name}\")\nprint(f\"Created: {channel.created}\")\nprint(f\"Is member: {channel.is_member}\")\nprint(f\"Unread count: {channel.unread_count}\")\nprint(f\"Members: {len(channel.members) if channel.members else 0}\")\n</code></pre>"},{"location":"examples/basic/#event-type-handling","title":"Event Type Handling","text":""},{"location":"examples/basic/#message-events-with-subtype","title":"Message Events with Subtype","text":"<pre><code>from slack_models import parse_event, SlackEventCallback, MessageEvent\n\n# Message with subtype (bot message)\nbot_message_payload = {\n    \"type\": \"event_callback\",\n    \"event\": {\n        \"type\": \"message\",\n        \"subtype\": \"bot_message\",\n        \"channel\": \"C1234567890\",\n        \"bot_id\": \"B1234567890\",\n        \"username\": \"testbot\",\n        \"text\": \"This is a bot message\",\n        \"ts\": \"1234567890.123456\"\n    },\n    \"team_id\": \"T1234567890\",\n    \"api_app_id\": \"A1234567890\"\n}\n\nevent = parse_event(bot_message_payload)\n\nif isinstance(event, SlackEventCallback):\n    if isinstance(event.event, MessageEvent):\n        message = event.event\n        print(f\"Message: {message.text}\")\n        print(f\"Subtype: {message.subtype}\")\n        print(f\"Bot ID: {message.bot_id}\")\n        print(f\"Username: {message.username}\")\n</code></pre>"},{"location":"examples/basic/#reaction-events","title":"Reaction Events","text":"<pre><code>from slack_models import parse_event, SlackEventCallback, ReactionAddedEvent\n\n# Reaction added event\nreaction_payload = {\n    \"type\": \"event_callback\",\n    \"event\": {\n        \"type\": \"reaction_added\",\n        \"user\": \"U1234567890\",\n        \"reaction\": \"thumbsup\",\n        \"item\": {\n            \"type\": \"message\",\n            \"channel\": \"C1234567890\",\n            \"ts\": \"1234567890.123456\"\n        },\n        \"item_user\": \"U0987654321\",\n        \"event_ts\": \"1234567890.654321\"\n    },\n    \"team_id\": \"T1234567890\",\n    \"api_app_id\": \"A1234567890\"\n}\n\nevent = parse_event(reaction_payload)\n\nif isinstance(event, SlackEventCallback):\n    if isinstance(event.event, ReactionAddedEvent):\n        reaction = event.event\n        print(f\"Reaction: {reaction.reaction}\")\n        print(f\"User: {reaction.user}\")\n        print(f\"Item type: {reaction.item.type}\")\n        print(f\"Channel: {reaction.item.channel}\")\n        print(f\"Message timestamp: {reaction.item.ts}\")\n</code></pre>"},{"location":"examples/basic/#error-handling","title":"Error Handling","text":""},{"location":"examples/basic/#validation-errors","title":"Validation Errors","text":"<pre><code>from pydantic import ValidationError\nfrom slack_models import parse_event\n\n# Invalid payload (missing required fields)\ninvalid_payload = {\n    \"type\": \"event_callback\",\n    \"event\": {\n        \"type\": \"message\",\n        # Missing required fields like channel, user, ts\n        \"text\": \"Hello\"\n    }\n}\n\ntry:\n    event = parse_event(invalid_payload)\n    print(\"Event parsed successfully\")\nexcept ValidationError as e:\n    print(\"Validation errors:\")\n    for error in e.errors():\n        field = \" -&gt; \".join(str(x) for x in error[\"loc\"])\n        message = error[\"msg\"]\n        print(f\"  {field}: {message}\")\n</code></pre>"},{"location":"examples/basic/#safe-parsing","title":"Safe Parsing","text":"<pre><code>from slack_models import parse_event\n\ndef safe_parse_event(payload: dict):\n    \"\"\"Safely parse an event with error handling.\"\"\"\n    try:\n        return parse_event(payload)\n    except Exception as e:\n        print(f\"Failed to parse event: {e}\")\n        return None\n\n# Usage\nevent = safe_parse_event(webhook_payload)\nif event:\n    print(f\"Successfully parsed: {type(event).__name__}\")\nelse:\n    print(\"Failed to parse event\")\n</code></pre>"},{"location":"examples/basic/#working-with-files","title":"Working with Files","text":""},{"location":"examples/basic/#file-events","title":"File Events","text":"<pre><code>from slack_models import parse_event, SlackEventCallback, FileCreatedEvent\n\n# File created event\nfile_payload = {\n    \"type\": \"event_callback\",\n    \"event\": {\n        \"type\": \"file_created\",\n        \"file\": {\n            \"id\": \"F1234567890\",\n            \"name\": \"example.txt\",\n            \"title\": \"Example File\",\n            \"mimetype\": \"text/plain\",\n            \"filetype\": \"text\",\n            \"pretty_type\": \"Plain Text\",\n            \"user\": \"U1234567890\",\n            \"size\": 1024,\n            \"mode\": \"snippet\",\n            \"is_external\": False,\n            \"external_type\": \"\",\n            \"is_public\": True,\n            \"public_url_shared\": False,\n            \"display_as_bot\": False,\n            \"username\": \"\",\n            \"url_private\": \"https://files.slack.com/files-pri/T1234567890-F1234567890/example.txt\",\n            \"url_private_download\": \"https://files.slack.com/files-pri/T1234567890-F1234567890/download/example.txt\",\n            \"permalink\": \"https://example.slack.com/files/U1234567890/F1234567890/example.txt\",\n            \"permalink_public\": \"https://slack-files.com/T1234567890-F1234567890-abc123\",\n            \"created\": 1234567890,\n            \"timestamp\": 1234567890\n        }\n    },\n    \"team_id\": \"T1234567890\",\n    \"api_app_id\": \"A1234567890\"\n}\n\nevent = parse_event(file_payload)\n\nif isinstance(event, SlackEventCallback):\n    if isinstance(event.event, FileCreatedEvent):\n        file_event = event.event\n        file_info = file_event.file\n        print(f\"File created: {file_info.name}\")\n        print(f\"Type: {file_info.pretty_type}\")\n        print(f\"Size: {file_info.size} bytes\")\n        print(f\"User: {file_info.user}\")\n        print(f\"Public: {file_info.is_public}\")\n</code></pre>"},{"location":"examples/basic/#type-checking-examples","title":"Type Checking Examples","text":""},{"location":"examples/basic/#runtime-type-checking","title":"Runtime Type Checking","text":"<pre><code>from slack_models import (\n    parse_event, SlackEventCallback, SlackUrlVerification,\n    MessageEvent, ReactionAddedEvent\n)\n\ndef handle_webhook(payload: dict):\n    \"\"\"Handle webhook with comprehensive type checking.\"\"\"\n    event = parse_event(payload)\n\n    # Check webhook type\n    if isinstance(event, SlackEventCallback):\n        # Check event type\n        if isinstance(event.event, MessageEvent):\n            handle_message_event(event.event)\n        elif isinstance(event.event, ReactionAddedEvent):\n            handle_reaction_event(event.event)\n        else:\n            print(f\"Unhandled event type: {type(event.event).__name__}\")\n\n    elif isinstance(event, SlackUrlVerification):\n        return event.challenge\n\n    else:\n        print(f\"Unhandled webhook type: {type(event).__name__}\")\n\ndef handle_message_event(message: MessageEvent):\n    \"\"\"Handle message event with type safety.\"\"\"\n    print(f\"Message: {message.text}\")\n    print(f\"Channel: {message.channel}\")\n\ndef handle_reaction_event(reaction: ReactionAddedEvent):\n    \"\"\"Handle reaction event with type safety.\"\"\"\n    print(f\"Reaction: {reaction.reaction}\")\n    print(f\"User: {reaction.user}\")\n</code></pre>"},{"location":"examples/basic/#generic-event-handler","title":"Generic Event Handler","text":"<pre><code>from typing import TypeVar, Type\nfrom slack_models import BaseSlackEvent, SlackEventCallback\n\nT = TypeVar('T', bound=BaseSlackEvent)\n\ndef handle_event_type(event: SlackEventCallback, event_type: Type[T]) -&gt; T | None:\n    \"\"\"Generic event handler with type checking.\"\"\"\n    if isinstance(event.event, event_type):\n        return event.event\n    return None\n\n# Usage\nevent = parse_event(webhook_payload)\nif isinstance(event, SlackEventCallback):\n    message = handle_event_type(event, MessageEvent)\n    if message:\n        print(f\"Message: {message.text}\")\n</code></pre>"},{"location":"examples/basic/#block-kit-examples","title":"Block Kit Examples","text":""},{"location":"examples/basic/#creating-basic-blocks","title":"Creating Basic Blocks","text":"<pre><code>from slack_models import (\n    SectionBlock, DividerBlock, TextObject, ButtonElement, ActionsBlock\n)\n\n# Create a section block with markdown text\nsection = SectionBlock(\n    text=TextObject(\n        type=\"mrkdwn\",\n        text=\"Welcome to the team! Here are some quick actions:\"\n    )\n)\n\n# Create a divider block\ndivider = DividerBlock()\n\n# Create an actions block with buttons\nactions = ActionsBlock(\n    elements=[\n        ButtonElement(\n            action_id=\"get_started\",\n            text=TextObject(type=\"plain_text\", text=\"Get Started\"),\n            style=\"primary\"\n        ),\n        ButtonElement(\n            action_id=\"learn_more\",\n            text=TextObject(type=\"plain_text\", text=\"Learn More\")\n        )\n    ]\n)\n\nprint(f\"Section text: {section.text.text}\")\nprint(f\"Button count: {len(actions.elements)}\")\n</code></pre>"},{"location":"examples/basic/#working-with-interactive-elements","title":"Working with Interactive Elements","text":"<pre><code>from slack_models import (\n    StaticSelectElement, Option, TextObject, DatePickerElement,\n    CheckboxesElement\n)\n\n# Create a static select menu\nselect_menu = StaticSelectElement(\n    action_id=\"priority_select\",\n    placeholder=TextObject(type=\"plain_text\", text=\"Select priority\"),\n    options=[\n        Option(\n            text=TextObject(type=\"plain_text\", text=\"High\"),\n            value=\"high\"\n        ),\n        Option(\n            text=TextObject(type=\"plain_text\", text=\"Medium\"),\n            value=\"medium\"\n        ),\n        Option(\n            text=TextObject(type=\"plain_text\", text=\"Low\"),\n            value=\"low\"\n        )\n    ]\n)\n\n# Create a date picker\ndate_picker = DatePickerElement(\n    action_id=\"due_date\",\n    placeholder=TextObject(type=\"plain_text\", text=\"Select due date\")\n)\n\n# Create checkboxes\ncheckboxes = CheckboxesElement(\n    action_id=\"features\",\n    options=[\n        Option(\n            text=TextObject(type=\"plain_text\", text=\"Email notifications\"),\n            value=\"email_notifications\"\n        ),\n        Option(\n            text=TextObject(type=\"plain_text\", text=\"SMS alerts\"),\n            value=\"sms_alerts\"\n        )\n    ]\n)\n\nprint(f\"Select options: {len(select_menu.options)}\")\nprint(f\"Checkbox options: {len(checkboxes.options)}\")\n</code></pre>"},{"location":"examples/basic/#processing-block-kit-from-events","title":"Processing Block Kit from Events","text":"<pre><code>from slack_models import parse_event, SlackEventCallback, MessageEvent\n\n# Example message event with blocks\nmessage_with_blocks = {\n    \"type\": \"event_callback\",\n    \"event\": {\n        \"type\": \"message\",\n        \"channel\": \"C1234567890\",\n        \"user\": \"U1234567890\",\n        \"text\": \"This message has blocks\",\n        \"ts\": \"1234567890.123456\",\n        \"blocks\": [\n            {\n                \"type\": \"section\",\n                \"text\": {\n                    \"type\": \"mrkdwn\",\n                    \"text\": \"Hello from Block Kit!\"\n                }\n            },\n            {\n                \"type\": \"divider\"\n            }\n        ]\n    }\n}\n\nevent = parse_event(message_with_blocks)\nif isinstance(event, SlackEventCallback):\n    if isinstance(event.event, MessageEvent):\n        message = event.event\n        if message.blocks:\n            print(f\"Message has {len(message.blocks)} blocks\")\n            for block in message.blocks:\n                print(f\"Block type: {block.type}\")\n</code></pre>"},{"location":"examples/events/","title":"Event Handling Examples","text":"<p>This guide provides comprehensive examples for handling different types of Slack events using slack-models.</p>"},{"location":"examples/events/#event-router-implementation","title":"Event Router Implementation","text":""},{"location":"examples/events/#basic-event-router","title":"Basic Event Router","text":"<pre><code>from slack_models import (\n    parse_event, SlackEventCallback, MessageEvent,\n    ReactionAddedEvent, ChannelCreatedEvent, TeamJoinEvent\n)\n\nclass SlackEventRouter:\n    def __init__(self):\n        self.handlers = {}\n\n    def register(self, event_type, handler):\n        \"\"\"Register a handler for a specific event type.\"\"\"\n        self.handlers[event_type] = handler\n\n    def route(self, payload: dict):\n        \"\"\"Route incoming webhook payload to appropriate handler.\"\"\"\n        try:\n            event = parse_event(payload)\n\n            if isinstance(event, SlackEventCallback):\n                event_type = type(event.event)\n                handler = self.handlers.get(event_type)\n\n                if handler:\n                    return handler(event.event)\n                else:\n                    print(f\"No handler for event type: {event_type.__name__}\")\n\n        except Exception as e:\n            print(f\"Error processing event: {e}\")\n            return None\n\n# Usage\nrouter = SlackEventRouter()\nrouter.register(MessageEvent, handle_message)\nrouter.register(ReactionAddedEvent, handle_reaction)\nrouter.register(ChannelCreatedEvent, handle_channel_created)\n\n# Process webhook\nrouter.route(webhook_payload)\n</code></pre>"},{"location":"examples/events/#decorator-based-event-router","title":"Decorator-Based Event Router","text":"<pre><code>from typing import Dict, Type, Callable\nfrom slack_models import BaseSlackEvent, SlackEventCallback, parse_event\n\nclass EventRouter:\n    def __init__(self):\n        self.handlers: Dict[Type[BaseSlackEvent], Callable] = {}\n\n    def handle(self, event_type: Type[BaseSlackEvent]):\n        \"\"\"Decorator to register event handlers.\"\"\"\n        def decorator(func):\n            self.handlers[event_type] = func\n            return func\n        return decorator\n\n    def process(self, payload: dict):\n        \"\"\"Process webhook payload.\"\"\"\n        event = parse_event(payload)\n\n        if isinstance(event, SlackEventCallback):\n            handler = self.handlers.get(type(event.event))\n            if handler:\n                return handler(event.event)\n\n# Usage\nrouter = EventRouter()\n\n@router.handle(MessageEvent)\ndef handle_message(message: MessageEvent):\n    print(f\"Message: {message.text}\")\n\n@router.handle(ReactionAddedEvent)\ndef handle_reaction(reaction: ReactionAddedEvent):\n    print(f\"Reaction: {reaction.reaction}\")\n\n# Process events\nrouter.process(webhook_payload)\n</code></pre>"},{"location":"examples/events/#message-event-handling","title":"Message Event Handling","text":""},{"location":"examples/events/#comprehensive-message-handler","title":"Comprehensive Message Handler","text":"<pre><code>from slack_models import MessageEvent, MessageItem\n\ndef handle_message_event(message: MessageEvent):\n    \"\"\"Handle message events with various subtypes.\"\"\"\n    print(f\"Message from {message.user}: {message.text}\")\n\n    # Handle message subtypes\n    if message.subtype == \"bot_message\":\n        print(f\"Bot message from {message.username}\")\n    elif message.subtype == \"file_share\":\n        print(\"File shared in message\")\n    elif message.subtype == \"message_changed\":\n        print(\"Message was edited\")\n    elif message.subtype == \"message_deleted\":\n        print(\"Message was deleted\")\n\n    # Handle threaded messages\n    if message.thread_ts:\n        print(f\"Thread reply to: {message.thread_ts}\")\n\n    # Handle edited messages\n    if message.edited:\n        print(f\"Message edited at: {message.edited.ts}\")\n        print(f\"Edited by: {message.edited.user}\")\n\n    # Handle file attachments\n    if message.files:\n        print(f\"Message has {len(message.files)} file(s)\")\n        for file in message.files:\n            print(f\"  - {file.name} ({file.pretty_type})\")\n\n    # Handle message reactions\n    if message.reactions:\n        print(\"Message reactions:\")\n        for reaction in message.reactions:\n            print(f\"  - {reaction.name}: {reaction.count} users\")\n</code></pre>"},{"location":"examples/events/#message-filtering","title":"Message Filtering","text":"<pre><code>from slack_models import MessageEvent\n\nclass MessageFilter:\n    def __init__(self):\n        self.filters = []\n\n    def add_filter(self, filter_func):\n        \"\"\"Add a filter function.\"\"\"\n        self.filters.append(filter_func)\n\n    def should_process(self, message: MessageEvent) -&gt; bool:\n        \"\"\"Check if message should be processed.\"\"\"\n        return all(f(message) for f in self.filters)\n\n# Filter functions\ndef not_bot_message(message: MessageEvent) -&gt; bool:\n    return message.subtype != \"bot_message\"\n\ndef has_text(message: MessageEvent) -&gt; bool:\n    return bool(message.text and message.text.strip())\n\ndef not_thread_reply(message: MessageEvent) -&gt; bool:\n    return message.thread_ts is None\n\ndef from_human_user(message: MessageEvent) -&gt; bool:\n    return message.user is not None\n\n# Usage\nmessage_filter = MessageFilter()\nmessage_filter.add_filter(not_bot_message)\nmessage_filter.add_filter(has_text)\nmessage_filter.add_filter(not_thread_reply)\nmessage_filter.add_filter(from_human_user)\n\ndef process_message(message: MessageEvent):\n    if message_filter.should_process(message):\n        print(f\"Processing message: {message.text}\")\n    else:\n        print(\"Message filtered out\")\n</code></pre>"},{"location":"examples/events/#reaction-event-handling","title":"Reaction Event Handling","text":""},{"location":"examples/events/#reaction-tracking","title":"Reaction Tracking","text":"<pre><code>from slack_models import ReactionAddedEvent, ReactionRemovedEvent\nfrom collections import defaultdict\n\nclass ReactionTracker:\n    def __init__(self):\n        self.reactions = defaultdict(lambda: defaultdict(set))\n\n    def add_reaction(self, event: ReactionAddedEvent):\n        \"\"\"Track reaction addition.\"\"\"\n        key = (event.item.channel, event.item.ts)\n        self.reactions[key][event.reaction].add(event.user)\n        print(f\"Reaction {event.reaction} added by {event.user}\")\n\n    def remove_reaction(self, event: ReactionRemovedEvent):\n        \"\"\"Track reaction removal.\"\"\"\n        key = (event.item.channel, event.item.ts)\n        self.reactions[key][event.reaction].discard(event.user)\n        print(f\"Reaction {event.reaction} removed by {event.user}\")\n\n    def get_reactions(self, channel: str, ts: str):\n        \"\"\"Get reactions for a specific message.\"\"\"\n        key = (channel, ts)\n        return dict(self.reactions[key])\n\n# Usage\ntracker = ReactionTracker()\n\ndef handle_reaction_added(reaction: ReactionAddedEvent):\n    tracker.add_reaction(reaction)\n\ndef handle_reaction_removed(reaction: ReactionRemovedEvent):\n    tracker.remove_reaction(reaction)\n</code></pre>"},{"location":"examples/events/#popular-reaction-analysis","title":"Popular Reaction Analysis","text":"<pre><code>from slack_models import ReactionAddedEvent\nfrom collections import Counter\n\nclass ReactionAnalyzer:\n    def __init__(self):\n        self.reaction_counts = Counter()\n        self.user_reactions = defaultdict(Counter)\n\n    def analyze_reaction(self, event: ReactionAddedEvent):\n        \"\"\"Analyze reaction patterns.\"\"\"\n        # Track overall reaction popularity\n        self.reaction_counts[event.reaction] += 1\n\n        # Track user reaction patterns\n        self.user_reactions[event.user][event.reaction] += 1\n\n        # Log popular reactions\n        if self.reaction_counts[event.reaction] % 10 == 0:\n            print(f\"Reaction {event.reaction} has been used {self.reaction_counts[event.reaction]} times!\")\n\n    def get_popular_reactions(self, limit: int = 10):\n        \"\"\"Get most popular reactions.\"\"\"\n        return self.reaction_counts.most_common(limit)\n\n    def get_user_favorite_reactions(self, user: str, limit: int = 5):\n        \"\"\"Get a user's favorite reactions.\"\"\"\n        return self.user_reactions[user].most_common(limit)\n\n# Usage\nanalyzer = ReactionAnalyzer()\n\ndef handle_reaction_added(reaction: ReactionAddedEvent):\n    analyzer.analyze_reaction(reaction)\n\n    # Print popular reactions periodically\n    popular = analyzer.get_popular_reactions(5)\n    print(f\"Top reactions: {popular}\")\n</code></pre>"},{"location":"examples/events/#channel-event-handling","title":"Channel Event Handling","text":""},{"location":"examples/events/#channel-lifecycle-tracking","title":"Channel Lifecycle Tracking","text":"<pre><code>from slack_models import (\n    ChannelCreatedEvent, ChannelDeletedEvent,\n    ChannelRenameEvent, Channel\n)\n\nclass ChannelTracker:\n    def __init__(self):\n        self.channels = {}\n        self.channel_history = []\n\n    def channel_created(self, event: ChannelCreatedEvent):\n        \"\"\"Track channel creation.\"\"\"\n        channel = event.channel\n        self.channels[channel.id] = channel\n        self.channel_history.append({\n            \"action\": \"created\",\n            \"channel_id\": channel.id,\n            \"channel_name\": channel.name,\n            \"creator\": channel.creator,\n            \"timestamp\": channel.created\n        })\n        print(f\"Channel #{channel.name} created by {channel.creator}\")\n\n    def channel_deleted(self, event: ChannelDeletedEvent):\n        \"\"\"Track channel deletion.\"\"\"\n        channel_id = event.channel\n        if channel_id in self.channels:\n            channel = self.channels[channel_id]\n            del self.channels[channel_id]\n            self.channel_history.append({\n                \"action\": \"deleted\",\n                \"channel_id\": channel_id,\n                \"channel_name\": channel.name,\n                \"timestamp\": event.event_ts\n            })\n            print(f\"Channel #{channel.name} deleted\")\n\n    def channel_renamed(self, event: ChannelRenameEvent):\n        \"\"\"Track channel renaming.\"\"\"\n        channel = event.channel\n        old_name = self.channels[channel.id].name if channel.id in self.channels else \"unknown\"\n\n        self.channels[channel.id] = channel\n        self.channel_history.append({\n            \"action\": \"renamed\",\n            \"channel_id\": channel.id,\n            \"old_name\": old_name,\n            \"new_name\": channel.name,\n            \"timestamp\": channel.created\n        })\n        print(f\"Channel renamed from #{old_name} to #{channel.name}\")\n\n    def get_channel_stats(self):\n        \"\"\"Get channel statistics.\"\"\"\n        return {\n            \"total_channels\": len(self.channels),\n            \"total_events\": len(self.channel_history),\n            \"recent_activity\": self.channel_history[-5:]\n        }\n\n# Usage\ntracker = ChannelTracker()\n\ndef handle_channel_created(event: ChannelCreatedEvent):\n    tracker.channel_created(event)\n\ndef handle_channel_deleted(event: ChannelDeletedEvent):\n    tracker.channel_deleted(event)\n\ndef handle_channel_renamed(event: ChannelRenameEvent):\n    tracker.channel_renamed(event)\n</code></pre>"},{"location":"examples/events/#team-event-handling","title":"Team Event Handling","text":""},{"location":"examples/events/#new-member-onboarding","title":"New Member Onboarding","text":"<pre><code>from slack_models import TeamJoinEvent, User\n\nclass OnboardingBot:\n    def __init__(self):\n        self.new_members = []\n        self.welcome_message = \"Welcome to the team! \ud83c\udf89\"\n\n    def handle_team_join(self, event: TeamJoinEvent):\n        \"\"\"Handle new team member joining.\"\"\"\n        user = event.user\n        self.new_members.append(user)\n\n        print(f\"New team member: {user.real_name} ({user.name})\")\n        print(f\"Email: {user.profile.email}\")\n        print(f\"Title: {user.profile.title}\")\n\n        # Send welcome message (simulated)\n        self.send_welcome_message(user)\n\n        # Notify admins if needed\n        if self.should_notify_admins(user):\n            self.notify_admins(user)\n\n    def send_welcome_message(self, user: User):\n        \"\"\"Send welcome message to new member.\"\"\"\n        message = f\"Hi {user.profile.first_name or user.name}! {self.welcome_message}\"\n        print(f\"Sending welcome message: {message}\")\n\n    def should_notify_admins(self, user: User) -&gt; bool:\n        \"\"\"Check if admins should be notified.\"\"\"\n        # Notify for external or guest users\n        return user.is_restricted or user.is_ultra_restricted\n\n    def notify_admins(self, user: User):\n        \"\"\"Notify admins about new member.\"\"\"\n        user_type = \"restricted\" if user.is_restricted else \"ultra_restricted\"\n        print(f\"Notifying admins: New {user_type} user {user.name} joined\")\n\n    def get_recent_members(self, limit: int = 10):\n        \"\"\"Get recently joined members.\"\"\"\n        return self.new_members[-limit:]\n\n# Usage\nonboarding = OnboardingBot()\n\ndef handle_team_join(event: TeamJoinEvent):\n    onboarding.handle_team_join(event)\n</code></pre>"},{"location":"examples/events/#file-event-handling","title":"File Event Handling","text":""},{"location":"examples/events/#file-activity-monitoring","title":"File Activity Monitoring","text":"<pre><code>from slack_models import FileCreatedEvent, FileDeletedEvent, File\n\nclass FileMonitor:\n    def __init__(self):\n        self.files = {}\n        self.file_activity = []\n\n    def file_created(self, event: FileCreatedEvent):\n        \"\"\"Monitor file creation.\"\"\"\n        file = event.file\n        self.files[file.id] = file\n\n        activity = {\n            \"action\": \"created\",\n            \"file_id\": file.id,\n            \"file_name\": file.name,\n            \"file_type\": file.pretty_type,\n            \"user\": file.user,\n            \"size\": file.size,\n            \"timestamp\": file.created\n        }\n        self.file_activity.append(activity)\n\n        print(f\"File created: {file.name} ({file.pretty_type})\")\n        print(f\"Size: {file.size} bytes\")\n        print(f\"User: {file.user}\")\n\n        # Check for large files\n        if file.size &gt; 10 * 1024 * 1024:  # 10MB\n            print(f\"\u26a0\ufe0f  Large file detected: {file.name} ({file.size} bytes)\")\n\n        # Check for sensitive file types\n        sensitive_types = ['pdf', 'doc', 'docx', 'xls', 'xlsx']\n        if file.filetype in sensitive_types:\n            print(f\"\ud83d\udcc4 Sensitive file type: {file.filetype}\")\n\n    def file_deleted(self, event: FileDeletedEvent):\n        \"\"\"Monitor file deletion.\"\"\"\n        file_id = event.file_id\n\n        if file_id in self.files:\n            file = self.files[file_id]\n            del self.files[file_id]\n\n            activity = {\n                \"action\": \"deleted\",\n                \"file_id\": file_id,\n                \"file_name\": file.name,\n                \"timestamp\": event.event_ts\n            }\n            self.file_activity.append(activity)\n\n            print(f\"File deleted: {file.name}\")\n\n    def get_file_stats(self):\n        \"\"\"Get file activity statistics.\"\"\"\n        total_size = sum(f.size for f in self.files.values())\n        file_types = {}\n\n        for file in self.files.values():\n            file_types[file.filetype] = file_types.get(file.filetype, 0) + 1\n\n        return {\n            \"total_files\": len(self.files),\n            \"total_size\": total_size,\n            \"file_types\": file_types,\n            \"recent_activity\": self.file_activity[-10:]\n        }\n\n# Usage\nmonitor = FileMonitor()\n\ndef handle_file_created(event: FileCreatedEvent):\n    monitor.file_created(event)\n\ndef handle_file_deleted(event: FileDeletedEvent):\n    monitor.file_deleted(event)\n</code></pre>"},{"location":"examples/events/#advanced-event-processing","title":"Advanced Event Processing","text":""},{"location":"examples/events/#event-correlation","title":"Event Correlation","text":"<pre><code>from slack_models import MessageEvent, ReactionAddedEvent\nfrom datetime import datetime, timedelta\n\nclass EventCorrelator:\n    def __init__(self):\n        self.message_reactions = {}\n        self.correlation_window = timedelta(hours=1)\n\n    def correlate_message_reactions(self, message: MessageEvent):\n        \"\"\"Start tracking reactions for a message.\"\"\"\n        key = (message.channel, message.ts)\n        self.message_reactions[key] = {\n            \"message\": message,\n            \"reactions\": [],\n            \"created_at\": datetime.now()\n        }\n        print(f\"Started tracking reactions for message: {message.text[:50]}...\")\n\n    def correlate_reaction(self, reaction: ReactionAddedEvent):\n        \"\"\"Correlate reaction with original message.\"\"\"\n        key = (reaction.item.channel, reaction.item.ts)\n\n        if key in self.message_reactions:\n            self.message_reactions[key][\"reactions\"].append(reaction)\n            print(f\"Reaction {reaction.reaction} correlated with message\")\n\n            # Analyze reaction patterns\n            self.analyze_reaction_patterns(key)\n\n    def analyze_reaction_patterns(self, key):\n        \"\"\"Analyze reaction patterns for a message.\"\"\"\n        data = self.message_reactions[key]\n        message = data[\"message\"]\n        reactions = data[\"reactions\"]\n\n        if len(reactions) &gt;= 3:\n            reaction_types = [r.reaction for r in reactions]\n            print(f\"Popular message (3+ reactions): {message.text[:50]}...\")\n            print(f\"Reactions: {', '.join(reaction_types)}\")\n\n    def cleanup_old_correlations(self):\n        \"\"\"Clean up old correlation data.\"\"\"\n        cutoff = datetime.now() - self.correlation_window\n\n        old_keys = [\n            key for key, data in self.message_reactions.items()\n            if data[\"created_at\"] &lt; cutoff\n        ]\n\n        for key in old_keys:\n            del self.message_reactions[key]\n\n        print(f\"Cleaned up {len(old_keys)} old correlations\")\n\n# Usage\ncorrelator = EventCorrelator()\n\ndef handle_message_for_correlation(message: MessageEvent):\n    correlator.correlate_message_reactions(message)\n\ndef handle_reaction_for_correlation(reaction: ReactionAddedEvent):\n    correlator.correlate_reaction(reaction)\n</code></pre>"},{"location":"examples/events/#event-batching","title":"Event Batching","text":"<pre><code>from slack_models import BaseSlackEvent\nfrom typing import List\nimport asyncio\n\nclass EventBatcher:\n    def __init__(self, batch_size: int = 10, batch_timeout: float = 5.0):\n        self.batch_size = batch_size\n        self.batch_timeout = batch_timeout\n        self.batch = []\n        self.batch_timer = None\n\n    def add_event(self, event: BaseSlackEvent):\n        \"\"\"Add event to batch.\"\"\"\n        self.batch.append(event)\n\n        # Reset timer\n        if self.batch_timer:\n            self.batch_timer.cancel()\n\n        # Process batch if full\n        if len(self.batch) &gt;= self.batch_size:\n            self.process_batch()\n        else:\n            # Set timer for timeout\n            self.batch_timer = asyncio.create_task(\n                self.batch_timeout_handler()\n            )\n\n    async def batch_timeout_handler(self):\n        \"\"\"Handle batch timeout.\"\"\"\n        await asyncio.sleep(self.batch_timeout)\n        if self.batch:\n            self.process_batch()\n\n    def process_batch(self):\n        \"\"\"Process the current batch.\"\"\"\n        if not self.batch:\n            return\n\n        print(f\"Processing batch of {len(self.batch)} events\")\n\n        # Group events by type\n        event_types = {}\n        for event in self.batch:\n            event_type = type(event).__name__\n            event_types[event_type] = event_types.get(event_type, 0) + 1\n\n        print(f\"Event types in batch: {event_types}\")\n\n        # Process events\n        for event in self.batch:\n            self.process_single_event(event)\n\n        # Clear batch\n        self.batch.clear()\n\n        if self.batch_timer:\n            self.batch_timer.cancel()\n            self.batch_timer = None\n\n    def process_single_event(self, event: BaseSlackEvent):\n        \"\"\"Process a single event.\"\"\"\n        print(f\"Processing {type(event).__name__}\")\n\n# Usage\nbatcher = EventBatcher(batch_size=5, batch_timeout=3.0)\n\ndef handle_any_event(event: BaseSlackEvent):\n    batcher.add_event(event)\n</code></pre>"}]}